# 硬链接

在 POSIX 系统，一个文件可以同时有多个名字。所有这些名字都是真实存在的，它们之间是平等的。

想给文件添加一个新名字，使用 `link()` 函数。（这个新的名字，也被称为硬链接）。创建一个硬链接，并不会复制文件的内容，只是增加一个新的名字。

一个文件可以在多个目录有多个名字。

通过多个文件系统对同一个文件创建硬链接？ 不行！大多数实现都办不到。如果你尝试这么做，`link()` 会报告错误。

内核维护着文件的物理信息，存储在一个 `inode` 结构。inode 中包含链接数和使用数。当调用 `link()` 创建一个链接时，链接数加 `1`；当调用 `unlink()` 删除一个链接时，链接数减 `1`。当文件被打开时，使用数加 `1`；当文件被关闭时，使用数减 `1`。当链接数为 `0`，并且使用数为 `0` 时，文件的相关数据将从文件系统删除（包括 `inode`）。

## API 
 

###: #include &lt;unistd.h&gt;

```c
#include <unistd.h>
```

###: link()

```c
int link(const char *oldname, const char *newname);
```

* Preliminary: | MT-Safe | AS-Safe | AC-Safe |
* Function

`link()` 函数创建一个新的硬链接。`oldname` 指定已有的文件名，`newname` 指定新的文件名。

执行成功返回 `0`；出错返回 `-1` 并设置 `errno` 值。相关的 `errno` 值如下所示：

* `EACCES` 你对新链接所在的目录没有写权限。

* `EEXIST` 名字 `newname` 已经存在了。如果你想替换，必须先将其删除。

* `EMLINK` 这个文件的硬链接数已达上限。（硬链接数上限是 `LINK_MAX` [→ 文件资源限制]()）。

* `ENOENT` 名字 `oldname` 不存在。

* `ENOSPC` 目录或文件系统包含的链接数满了，不能再扩充。

* `EPERM` 在 GNU/Linux 和其他一些系统，只有特权用户才能为目录创建新链接。如果你不是特权用户，就会报告这个错误。

* `EROFS` 无法创建新链接，因为所在的文件系统是只读的。

* `EXDEV` 名字 `newname` 和 `oldname` 位于不同的文件系统。

* `EIO` 当尝试读写文件系统时，出现硬件错误。