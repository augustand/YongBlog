

## UNIX 系统结构

操作系统是管理和分配计算机资源（如 CPU、RAM和设备）的核心层软件，这种软件通常称为 **kernel** （内核）。

**kernel** 的接口称为 **system calls** （系统调用）。**library routines** （公用函数库） 构建在**system calls** 基础上。应用程序可以使用 **system calls**，也可以使用 **library routines**。

**shell** 是一个特殊的应用程序，为运行其他应用程序提供了一个接口。

![UNIX](/images/posix/os_kernel.jpg)

## 内核

### 何谓内核？

早期的 UNIX 系统称其内核为 UNIX。后来逐渐实现了虚拟内存机制，内核名称变更为 vmunix。在 Linux 系统中，一般会把内核可执行文件命名为 */boot/vmlinuz* （或者类似的文件），使用 z 替换 linux 末尾的 x，表明内核是经过压缩的可执行文件。



### 内核的主要任务

* 进程调度：UNIX 系统属于抢占式多任务操作系统。多任务，是指多个进程可以同时驻留在内存，并且每个进程都能获得 CPU 的使用权。抢占，是指控制进程对 CPU 的使用，以及每个进程可以使用的最长时间。这些由内核进程调度程序决定。

* 内存管理：物理内存（RAM）属于有限资源，以公平、高效的方式在进程间共享这一资源。内核采用了虚拟内存管理机制，这项技术有以下两方面优势：
 * 进程与进程之间，进程与内核之间彼此隔离，一个进程无法读写内核或者其他进程的内存。
 * 只需要将进程的一部分保持在内存中，即降低了每个进程对内存的消耗，又可以在 RAM 中同时加载更多的进程。

* 提供文件系统：内核在磁盘上提供文件系统，允许对文件执行创建、读取、更新、删除等操作。

* 访问设备：计算机外界设备（鼠标、键盘、磁盘、磁带驱动器等）可实现与外部世界的通信。内核为程序访问设备提供了简化版的标准接口，同时仲裁多个进程对同一设备的访问。

* 创建和终止进程：内核可以将新程序载入内存，为其提供计算机资源（CPU、内存、文件访问等）。一旦进程执行完毕，内核还会确保释放进程占用的资源，以供后续程序使用。

* 网络通信：内核以用户进程的名义收发网络消息，包括将网络数据包路由至目标系统。

* 提供系统调用：提供内核入口点方便进程向内核发出请求，执行各种任务。



### 内核的视角

内核是运行系统的中枢所在，对系统的一切无所不知、无所不能，为系统上所有进程的运行提供便利。哪个进程开始使用 CPU，何时使用，使用多久，都由内核说了算。在内核维护的数据结构中，包含了与所有正在运行的进程有关的信息。随着进程的创建、状态发生变化、终结，内核会及时更新这些数据结构。内核维护的底层数据结构可将程序使用的文件名转换为磁盘的物理位置。此外，每个进程的虚拟内存与计算机物理内存及磁盘交换区之间的映射关系，也记录在内核维护的数据结构中。进程间的所有通信都要通过内核提供的通信机制来完成。内核响应进程发出的请求，创建新的进程，终结现有进程。最后，执行与输入输出设备指尖的所有直接通信，按需与用户进程交互信息。



### 内核态和用户态

现代处理器架构允许 CPU 至少在两种不同状态下运行，即内核态和用户态。执行硬件指令可以使 CPU 在这两种状态下来回切换。与之对应，将虚拟内存区域划分为内核空间和用户空间。在内核态运行时，CPU 既可以访问内核空间内存，也可以访问用户空间内存；在用户态运行时，CPU 只能访问用户空间内存。

只有处理器运行在内核态时，才能执行某些特定操作。比如：关闭系统，访问内存管理硬件，设备 IO 操作初始化。这能确保用户进程无法访问内核指令和数据结构，也无法执行破坏系统运行的操作。

###

## shell

用户在登录 UNIX 系统时，先键入登录名，然后键入口令。系统在其口令文件 */etc/passwd* 中查看登录名。口令文件中的登录项由 7 个字段组成，依次是：登录名、加密口令、用户号码、组号码、注释、初始目录、shell ：
*`king:x:1000:1000:king,,,:/home/king:/bin/bash`*

用户登录后，系统通常先显示一些系统信息，然后用户就可以向 **shell** 程序键入命令。**shell** 是一个命令行解释器，读取用户输入，然后执行命令。**shell** 的用户输入通常来自终端，有时则来自文件。

![shell](/images/posix/os_shell.jpg)



<table>
<tr>
  <th class="ta-c" style="min-width:180px">名称</th>
  <th class="ta-c" style="min-width:90px">路径</th>
  <th class="ta-c" style="min-width:110px">FreeBSD 8.0</th>
  <th class="ta-c" style="min-width:110px">Linux 3.2.0</th>
  <th class="ta-c" style="min-width:150px">Mac OS X 10.6.8</th>
  <th class="ta-c" style="min-width:100px">Solaris 10</th>
</tr>
<tr>
  <td class="ta-l">Bourne shell</td>
  <td class="ta-l">/bin/sh</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">bash 的副本</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">Bourne again shell</td>
  <td class="ta-l">/bin/bash</td>
  <td class="ta-c">可选的</td>
  <td class="ta-c">•</td>
  <td class="ta-c">bash 的副本</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">C shell</td>
  <td class="ta-l">/bin/csh</td>
  <td class="ta-c">链接至 tcsh</td>
  <td class="ta-c">可选的</td>
  <td class="ta-c">链接至 tcsh</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">Korn shell</td>
  <td class="ta-l">/bin/ksh</td>
  <td class="ta-c">可选的</td>
  <td class="ta-c">可选的</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">TENEX C shell</td>
  <td class="ta-l">/bin/tcsh</td>
  <td class="ta-c">•</td>
  <td class="ta-c">可选的</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
</table>

## 磁盘和分区

### 磁盘

普通文件和目录通常存放在磁盘设备里。（其他设备也能存放，比如 CD-ROM，闪存卡，虚拟磁盘）。

磁盘设备是一种机械装置，由一个或者多个高速旋转的盘片组成。通过快速移动读写磁头，来获取和修改磁盘表面的磁性编码信息。磁盘信息存储在位于磁盘表面称为＂磁道＂的一组同心圆上。＂磁道＂划分为若干＂扇区＂。＂扇区＂大小通常是 `512B` 或者 `512B 的倍数`，是磁盘设备可以读写的最小数据单元。 



### 磁盘分区

可以将磁盘划分为一个或者多个分区。内核将每个分区视为位于 */dev* 目录下的单独设备。磁盘分区可以容纳任何类型的信心，但是通常只会包含以下之一：

* 文件系统：用来存放常规文件
* 数据区域：作为裸设备进行访问（一些数据库管理系统会使用）
* 交换区域：用于内核的内存管理

###

## 文件系统

### 一切皆文件

UNIX 遵循＂一切皆文件＂的理念，很多和系统的交互操作是通过读写文件来完成的。内核维护着一套单根目录结构，以组织系统的所有文件。根目录是 */*，是所有文件和目录的始祖。



### 逻辑块

文件系统分配空间的基本单位是＂逻辑块＂，对应磁盘设备上＂若干连续的扇区＂。一般是 `2 的指数倍 * 扇区大小` ，通常比＂扇区＂大，但是必须小于＂页＂-内存管理单元的最小寻址单元。常见的＂逻辑块＂大小有`512B`，`1024B`，`4096B`。



### 逻辑块对齐

在内核中所有的文件系统操作，都是基于＂逻辑块＂来执行的。因此，所有 IO 操作都是在＂逻辑块＂大小或者＂逻辑块＂大小的整数倍上执行，也就是说，当你只想读取一个字节时，实际上仍要读取整个＂逻辑块＂。想写 4.5 个＂逻辑块＂的数据？对不起，实际上你需要写 5 个＂逻辑块＂的数据。（用户空间 ---- 内核缓冲区）。对于非＂逻辑块＂整数倍大小的操作效率很低，内核会对 IO 进行＂修补＂，确保所有操作是在＂逻辑块＂整数倍大小进行，并且和下一个＂逻辑块＂对齐。



### 文件系统的挂载和卸载

文件系统提供全局统一的文件和目录命名空间。在文件和目录的全局命名空间中，可以分别添加和删除文件系统，这些操作称为挂载（mounting）和卸载（unmounting）。每个文件系统都需要挂载到命名空间的特定位置，该位置称为＂挂载点＂。在＂挂载点＂可以访问文件系统的根目录。例如，把 CD 挂载到 */media/cdrom*，就可以通过*/media/cdrom* 访问该 CD 文件系统的根目录。

超级用户可以使用如下命令来挂载文件系统： `$ mount device directory` 。将名为 device 的文件系统挂载到directory 所指定的目录，即文件系统的挂载点。可以使用 `$ umount device` 命令卸载文件系统，然后在另一个挂载点再次挂载文件系统。`$ mount` 列出当前已挂载的文件系统。

第一个被挂载的文件系统在命名空间的根目录 */* 下，称为根文件系统。UNIX 系统必定有个根文件系统，其他文件系统的挂载点则是可选的。



### Linux 支持的文件系统

<table>
<tr>
  <td class="ta-l">本地文件系统</td>
  <td class="ta-l">ext2，ext3</td>
</tr>
<tr>
  <td class="ta-l">其他原生 UNIX 系统的文件系统</td>
  <td class="ta-l">Minix 文件系统，System V 文件系统，BSD 文件系统</td>
</tr>
<tr>
  <td class="ta-l">非 UNIX 系统的文件系统</td>
  <td class="ta-l">微软的 FAT，FAT32，NTFS 文件系统</td>
</tr>
<tr>
  <td class="ta-l">媒体文件系统</td>
  <td class="ta-l">ISO 9660 CD-ROM 文件系统</td>
</tr>
<tr>
  <td class="ta-l">网络文件系统</td>
  <td class="ta-l">SUN NFS 文件系统，IBM 和微软的 SMB 文件系统，Novell NCP，Coda 文件系统</td>
</tr>
<tr>
  <td class="ta-l">日志文件系统</td>
  <td class="ta-l">ext3，ext4，Reiserfs，JFS，XFS，Btrfs</td>
</tr>
</table>

Linux 支持种类繁多的文件系统，*/proc/filesystems* 可以查看当前内核支持的文件系统类型。



### 文件系统的组成

* 引导块：文件系统的首块。不为文件系统使用，只是包含用来引导操作系统的信息。所有文件系统都设有引导块。

* 超级块：紧随引导块之后的一个独立块，包含与文件系统相关的参数信息，包括：
    * inode 表容量
    * 逻辑块的大小
    * 文件系统的大小

* inode 表：文件系统中的每个文件或目录在 inode 表都对应唯一一条记录，包含了文件的各种信息：
  * 文件类型（普通文件 | 目录 | 符号链接 | 字符设备 | 块设备 | 套接字 | FIFO）
  * 文件属主
  * 文件属组
  * 3 类用户的访问权限
  * 3 个时间戳，最后访问时间、最后修改时间、文件状态的最后修改时间
  * 指向文件的硬链接数量
  * 文件的字节大小
  * 实际分配给文件的＂逻辑块＂数量，以 `512B` 为单位。考虑文件中包含空洞，分配给文件的块数可能会低于根据文件正常大小计算出的块数
  * 文件数据块的地址

* 数据块：存放的数据

```
#*      *********************************************************************
#*      *      分区      |           分区          |           分区           *   磁盘
#*      *********************************************************************
#*                     ⋰                          ⋱
#*                   ⋰                              ⋱
#*                 ⋰                                  ⋱
#*                ***************************************
#*                * 引导块 | 超级块 | inode 表 |   数据块  *                       文件系统
#*                ***************************************
```



### 文件元数据

每个文件均对应一个 **inode** （索引节点）。**inode** 由文件系统进行唯一数值编址，存储了与文件有关的元数据，例如文件的访问权限、最后访问时间戳、属主、属组、大小以及文件数据的存储位置。

可以使用 **ls -i** 查看一个文件的 **inode** 编号：

```sh
$ ls -i
1689459 Kconfig  1689461 main.c  1680144 process.c  1680137 Makefile
```



### 文件类型

在文件系统中，会对文件进行类型标记，表明其种类。其中一种用来表示普通数据文件，常称之为＂普通文件＂。其他文件类型包括：＂目录＂、＂符号链接＂、＂块设备文件＂、＂字符设备文件＂、＂FIFO＂、＂套接字＂。



### 访问权限

当调用 `open(pathname, flags, mode)` 时，除非创建新文件，否则会忽略 `mode` 参数。当使用 `O_CREAT` 创建新文件时，`mode` 提供了新文件的权限。参数 `mode` 是常见的 UNIX 权限位集合，比如八进制数 `0644`(属主可读写、属组只读、其他人只读)。每个 UNIX 系统对权限位的实现采用了相同的方式。虽然技术上不可移植，但是在任何系统指定 `0644` 这样的数值效果都是一样的。为了弥补 `mode` 比特位的不可移植性，POSIX 引入了一组可按位操作的常数。 

#### 访问权限共有 3 类用户

* Owner - 文件属主
* Group - 文件数组
* Other - 其他用户

#### 可为每类用户授予的访问权限

* Read - 可读 （对于目录，可列出目录下的内容）
* Write - 可写 （对于目录，可在目录内创建、删除文件）
* Execute - 可执行 （对于目录，可以访问目录中的文件）



#### 访问权限位掩码

实际上，最终写入磁盘的权限位是由 `open(pathname, flags, mode)` 系统调用的 `mode` 参数和用户的文件创建掩码（umask）执行按位与操作而得到。umask 是进程级属性，通常由 **login shell** 设置，通过调用 `umask()` 来修改，支持用户修改新创建的文件和目录的权限。大多数 **login shell** 会将 umask 默认设置为 `022`<br /（`----w--w-`），屏蔽属组和其他用户的写权限。

`struct stat` 结构中的 `st_mode` 字段的低 12 位定义了文件权限。其中前 3 位为专用位，分别是＂保留用户位＂、＂保留组位＂、＂sticky 位＂，后 9 位构成权限的掩码。

要更改文件访问权限，进程必须有 `CAP_FOWNER` 权限或者＂有效用户号码＂和＂文件属主号码＂相匹配。



#### 属主和属组

`struct stat` 结构中的 `st_uid` `st_gid` 分别表示文件的属主和属组。

新文件的属主是创建进程的＂有效号码＂。

新文件的属组则相对复杂些。默认情况下，使用创建进程的＂有效号码＂。System V 通过这种方式确定，Linux 也采用这种方式。但是 BSD 定义了自己的方式：新文件的属组与父目录的属组相同。在 Linux 上，如果新文件的父目录设置了 setgid 位，默认也是这种行为。虽然大多数 Linux 系统采用 System V 行为，但是 BSD 行为也有存在的可能。因此，对于新建文件的属组非常关注的代码，需要通过系统调用 `fchown(fd, owner, group)` 手动设置属组。

有 `CAP_CHOWN` 权限的进程可以改变文件的属主和属组为任意值。非特权进程可以将自己拥有文件的属组改为其从属的任一属组。属主或者属组发生改变时，文件的＂saved set-user-ID＂和＂saved set-group-ID＂权限位都会随之关闭。（当定义在 `<unistd.h>` 的 `_POSIX_CHOWN_RESTRICTED` 有效时---可以用 `pathconf()` `fpathconf()` 查询）



### 文件时间戳

文件维护 3 个时间戳：

* st_atim - 文件数据的最后访问时间戳，比如 `read()`
* st_mtim - 文件数据的最后修改时间戳，比如 `write()`
* st_ctim - i 节点状态的最后更改时间戳，比如 `chmod()` `chown()`         

###

## 虚拟文件系统

### 何谓虚拟文件系统？

UNIX 支持的各文件系统，实现细节是不一样的（比如文件块分配，目录的组织等等）。如果每个与文件系统打交道的程序，都要了解各文件系统不同的实现细节，那么编写与各文件系统交互的程序将是不可能完成的任务。为此，内核提供了＂虚拟文件系统＂（VFS，也叫＂虚拟文件转换＂），用于提供一个抽象层，定义一套通用接口，来简化对不同文件系统的操作。



### 虚拟文件系统的接口

每种文件系统都会提供 VFS 接口的实现。VFS 接口，与涉及文件系统和目录的所有常规系统调用对应，包括 `open()` `read()` `write()` `lseek()` `close()` `truncate()` `stat()` `mount()` `umount()` `mmap()` `mkdir()` `link()` `unlink()` `symlink()` `rename()`。（VFS 抽象层模型，精确仿照传统的 UNIX 文件系统模型）。



```
#*                ****************************************************
#*                *                     应用程序                      *
#*                ****************************************************
#*                                         |
#*                                         |
#*                 ***************************************************
#*                 *                  虚拟文件系统 VFS                 *
#*                 ***************************************************
#*                          /        /      /                
#*                         /        /      /                  
#*                 ********  ********  ************  ********  *******
#*                 * ext2 *  * ext3 *  * Reuserfs *  * VFAT *  * NFS *
#*                 ********  ********  ************  ********  *******
#*                    |         |           |           |         |
#*                    |         |           |           |         |
#*                 ***************************************************
#*                 *                    内核缓冲区                     *
#*                 ***************************************************
#*                                          |
#*                                          |
#*                 ***************************************************
#*                 *                       磁盘                       *
#*                 ***************************************************
```

###

## 虚拟地址空间

### 虚拟内存

UNIX 系统将其物理内存虚拟化。进程并不能直接在物理内存上寻址，而是由内核为每个进程维护一个特殊的虚拟地址空间（virtual address space）。这个地址空间是线性的，从 `0` 开始，一直到某个最大值。



### 页

内存由比特位组成，8 个比特位组成一个字节。字节又组成字，字组成页。对于内存管理，页是最重要的：页是内存管理单元（MMU）可以管理的最小可访问内存单元。因此，虚拟空间是由许多页组成的。系统的体系结构和机型决定了页的大小。页的大小是固定的，典型的页大小有 `4096B` （32 位系统） 和 `8012B` （64 位系统）。



### 有效页和无效页

32 位地址空间包含约一百万的 `4092B` 的页，而 64 位的地址空间包含数倍的 `8192B` 的页。一个进程不可能访问所有这些页。这些页可能并没有任何意义。因此，也有两种状态：有效的和无效的。一个有效页和实际的数据相关联，可能是物理内存（RAM），也可能是二级存储介质（比如交换分区或者磁盘上的文件）。一个无效页没有任何意义，表示它没有被分配或使用。访问一个无效页会引发一个段错误。

地址空间不一定是连续的，虽然是线性编址，但实际上中间有很多未编址的小区域。



### 页调度

如果一个有效页和二级存储的数据有关，则进程不能访问该页，除非把这个页和物理内存中的数据关联。如果一个进程要访问这样的页，那么内存管理单元（MMU）会产生页错误。然后，内核会介入，把数据从二级存储切换到物理内存中，而且对用户＂透明＂。由于虚拟内存要比物理内存大得多，内核可能需要把数据从内存中切换出来，从而为后面要 ＂Page in＂ 的页腾出更多空间。因为，内核也许要把数据从物理内存切换到二级存储，这个过程称为 ＂Paging out＂。为了优化性能，实现后续 ＂Page in＂ 的操作代价最低，内核往往是把物理内存中近期不可能使用的页替换出来。



### 共享

虚拟内存中的多个页面，甚至是不同进程的虚拟地址空间，也有可能会映射到同一个物理页面。通过这种方式，可以支持不同的虚拟地址空间共享物理内存上的数据。比如，在多个进程映射大数据库，虽然进程的数据库都在其＂虚拟地址空间＂中，但实际数据只存在 RAM 中。



### 写时复制

共享的数据可能是只读的、只写的或者可读可写的。当一个进程试图写某个共享的可写页时，可能发生两种情况。最简单的是内核允许写操作，在这种情景下，所有共享这个页的进程都将看到这次写操作的结果。通常，允许大量进程对同一页面读写需要某种程度上的合作和同步机制。另一种情况场景下，内存管理单元（MMU）拦截这次写操作，并产生一个异常。内核会相应＂透明＂地创建一份该页的拷贝，支持继续对新的页面执行写操作。这种方法称为＂写时复制＂。实际上，允许进程读取共享的数据，可以有效节省空间。当一个进程想要写一个共享页面时，可以立刻获得该页的唯一拷贝，这使得内核工作起来就像每个进程都始终有它自己的私有拷贝。写时复制是以页为单位进行的，通过这种方式，多个进程可以高效共享一个大文件。每个进程只有在对共享页写时才能获得一份新的拷贝。



### 进程和页

任一时刻，每个程序仅有部分页需要驻留在物理内存。这些页构成了所谓的驻留集。程序未使用的页拷贝保存在交换区内---磁盘空间中的保留区域，作为计算机 RAM 的补充---仅在需要时才会载入物理内存。如果进程访问的页目前并未驻留在物理内存中，将会发生页错误，内核即可挂起进程的执行，同时从磁盘中将该页载入内存。

内核为每个进程维护一个页表，记录了每页在进程虚拟地址空间中的位置。页表中的每一项要么指出一个虚拟页要么在 RAM 中某个位置，要么驻留在磁盘上某个位置。



### 内存区域

内核将某些有相同特征的页组织成段，也叫内存区域或者映射，下面是一些在每个进程都可以看到的内存区域：
* 文本段：内含机器语言指令，只读，可共享。可用于在进程间映射程序代码。
* 初始化的数据段：初始化的全局变量和静态变量。当可执行文件被加载到内存时，读取这些值。
* 未（零）初始化的数据段：未初始化的全局变量和静态变量。启动程序前，这些值在内存中被初始化为 ０。（程序在磁盘上存储时，没有必要为其未初始化的变量分配存储空间，只需记录这些未初始化的数据段的位置和大小。运行时由程序加载器来分配内存空间）。
* 栈：动态变化，由帧组成。当前调用的函数，会分配一个帧，存储函数的局部变量，实参，返回值。
* 堆：动态变化，运行时分配内存。
>
```
#|                        +---------------+
#|                        | Kernel        | 映射到进程虚拟内存，但程序无法访问
#|             0xC0000000 +---------------+
#|                        | argv, environ |
#|                        +---------------+
#|                        | Stack       ↓ | 
#|           Top of Stack +...............+
#|                        |               |
#|                        |               | 
#|          Program Break +...............+
#|                        |               |
#|                        | Heap        ↑ |
#|                        |               |
#|                        +---------------+
#|                        | Uninitialized |
#|                        +---------------+
#|                        | Initialized   | 
#|                        +---------------+
#|                        | Text          | 
#|             0x08048000 +---------------+
#|             0x00000000 +---------------+
```



### 虚拟内存的优点

虚拟内存管理使进程的虚拟地址空间和 RAM 物理地址空间隔离，带来很多优点：
* 进程和进程、进程和内核间是隔离的，所以一个进程不能读取或者修改另一进程或者内核的内存。这是因为每个进程的页表记录指向的 RAM 或交换区中都是不同的。
* 适当情况下，多个进程可以共享内存。这是由于内核可以使不同进程的页表记录指向相同的 RAM 区域。
* 便于实现内存保护。可以对页表记录进行标记，以表示相关的页可读、可写、可执行或者这些保护措施的组合。
* 无需关注 RAM 布局 。
* 程序加载和运行更快。
* 容纳的进程数量增多。

###

## 动态内存分配

### program break

改变堆的大小（即分配或释放内存），其实就像命令内核改变进程的 program break 位置一样简单。

最初，program break 正好位于未初始化数据段末尾之后。在 program break 的位置抬升后，程序可以访问新分配区域内的任何内存，而此时物理内存页尚未分配。内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页。



### malloc

`malloc(size)` 首先扫描由 `free(ptr)` 释放的空闲内存表，寻找尺寸 >= 要求的空闲内存。如果刚好相等，就把它直接返回给调用者。如果过大，把尺寸相当的部分返回给调用者，把剩余的部分保留在空闲内存表中。

如果在空闲内存表中没有找到足够大的内存，调用 `sbrk(end_data_segment)` 增加 program break 的位置，以分配更大的内存。为了减少 `sbrk(increment)` 调用次数，`malloc(size)` 并非严格按照所需要的字节数来分配内存，而是以虚拟内存页的整数倍大小来增加 program break，将超出部分置于空闲内存表。

当 `malloc(size)` 分配内存时，会额外分配几个字节来存储一个整数，用来记录这块内存大小。这个整数位于内存块的起始处，实际返回给调用者的内存地址恰好位于这个整数字节之后。

```
#|   +-----------------------------------------------------------------+
#|   | 内存块大小(L) | 供调用者使用的内存                                  |
#|   +-----------------------------------------------------------------+
#|                 ^
#|                 malloc() 返回的地址
```



### free

一般情况下，`free(ptr)` 并不降低 program break 的位置，而是将这块内存添加到空闲内存列表中，供后续的内存分配。这么做有以下几个原因：

* 释放的内存块通常位于堆中间，降低 propram break 是不可能的。
* 最大限度减少执行 `sbrk(increment)` 调用次数。
* 多数情况下，降低 prgram break 的位置不会对分配大量内存的程序有帮助。

将内存块置于空闲内存表时，`free(ptr)` 使用内存块本身的空间来存放链表指针，将自身添加到列表中。

```
#|   +------------------------------------------------------------------+
#|   | 内存块尺寸(L) | 前一空闲内存块地址 | 后一空闲内存块地址 | 剩余空闲内存   |
#|   +------------------------------------------------------------------+
#|                        空闲内存表中的内存块
```

将相邻空闲内存块合并为一块更大的空闲内存，可以避免在空闲内存列表中包含大量的小块内存，导致内存空间太小，难以满足后续的内存申请。Glibc 的 `free(ptr)` 实现，在堆顶空闲内存＂足够＂大的时候，会调用 `sbrk(increment)` 来降低 program break 的位置，减少了调用 `sbrk(increment)` 的次数。（＂足够＂取决于 `malloc(size)` 函数行为的控制参数，`128 K` 为典型值）。



### 匿名内存映射

匿名内存映射与基于文件的映射很相似，但是不是基于文件的。实际上，匿名内存映射只是一块用 `0` 初始化的大的内存块，以供用户使用。可以把它想象成单独为某次分配而使用的堆。由于这些映射并不是基于堆，因此不会造成数据段碎片。（匿名内存映射得到的内存块，使用上和通过堆获得的内存块相同）。

#### 匿名内存映射的好处

* 无需关心碎片。程序不再需要这块内存的时候，只要撤销映射，这块内存就会立刻归还给系统。
* 内存大小是可调整的，可以设置权限，还能像普通映射一样接收参数。
* 每次分配都存在于独立的内存映射中，不需要管理一个全局的堆。

#### 和堆相比，匿名内存映射的缺点

* 每个内存映射都是页大小的整数倍。所以，如果不是页大小整数倍的分配会浪费大量的空间。对于较小的分配来说，空间的浪费更加显著。
* 创建一个新的内存映射，比从堆中返回内存的代价高，因为使用堆几乎不涉及任何内核操作。分配的空间越小，这些代价带来的损失越大。



### Glibc malloc

Glibc 的 `malloc()`，通过数据段（堆）来满足小空间的分配，使用匿名内存映射来满足大空间的分配。（这个临界值是可配置的，目前是 `128KB`）。



### 更多的动态内存分配方案

* `libmalloc()`，基于 SVR4 的 UNIX 系统，如 Solaries，包含了 libmalloc 库，提供一套与 ISO C 存储空间分配函数相匹配的接口
* `vmalloc()`，Vo 库，允许进程对不同的存储区使用不同的技术
* `quick-fit`，快速适配算法，现在许多分配程序都基于快速适配
* `jemalloc`，FreeBSD 8.0 的默认存储空间分配程序，是 `malloc` 族在 FreeBSD 的实现
* `TCMalloc`，替代 `malloc` 函数族以提供高性能，高扩展和高存储效率。从高速缓存中分配缓冲区以及释放缓冲区到高速缓存中时，使用线程－本地高速缓存来避免锁开销。开源的，是 Google-perftools 工具中的一个
* `alloca`，在函数栈上分配存储空间

###

## 数据对齐

### 为何数据对齐？

数据对齐是指数据在内存中的存储排列方式。如果内存地址 a 是 2^n 的整数倍，a 就是 n 字节对齐。处理器、内存子系统以及系统中的其它组件都有特定的对齐需求。比如，大多数处理器的工作单位是字，只能访问字对齐的内存地址。同样，内存管理单元也只能处理页对齐的内存地址。

如果一个变量的内存地址是它大小的整数倍，就称为“自然对齐”。比如，对于一个 32 位的 int 变量，其大小是 4 字节，如果它的地址是 4 字节的整数倍，那就是自然对齐了。

数据对齐的规则是依赖于硬件的，因此不同系统的对齐规则不同。在编写可移植的代码的时候，编程人员一定要注意不要破坏了数据对齐规则。

在大多数情况下，编译器和 C 库会自动处理对齐问题。POSIX 规定通过 `malloc()` `calloc()` `realloc()` 等返回的内存空间对于 C 中的标准类型都应该是对齐的。在 Linux 中，这些函数返回的地址在 32 位系统是以 8 字节为边界对齐，在 64 位系统是以 16 字节为边界对齐的。

有时，变成人员需要动态分配更大的内存，如页。虽然有很多不同的目的，最常见的需求是要对直接块 IO 或者其他软硬件通信的缓冲区对齐。为此，POSIX 1003.1d 提供了 `posix_memalign()` 函数。



### 非标准的和复杂的数据类型的对齐

对齐问题并不局限于标准类型与动态内存分配的自然对齐。比如说，非标准的和复杂的数据类型的对齐问题会比标准类型的更复杂。对不同类型的指针进行赋值以及强制类型转换的时候，对齐问题就变得更为重要。

非标准的和复杂的数据类型的对齐可以遵循以下规则

* 结构体的对齐要求和它的成员中最大的那个类型是一样的。比如，`struct T {int a; char b;}` 最大的是 4 字节对齐的 32bit 的 int 类型，那么这个结构至少以 4 字节对齐。

* 结构体也带来了填充问题，以此来保证每一个成员都符合各自的对齐要求。因此，如果一个 char 后跟着一个 int，比如 `struct T {char a; int b; }`，编译器会自动插入 3 个字节作为填充来保证 int 以 4 字节对齐。编程人员有时需要注意一下结构体中成员变量的顺序，比如按成员变量类型大小降序来定义它们，从而减少由于填充所带来的空间浪费。使用 GCC 编译时，加入 -Wpadded 选项可以帮助你实现这个优化，当编译器隐式填充时，它会发出警告。

* 一个联合类型的对齐和联合类型里类型大小最大的一致。

* 一个数组的对齐和数组里的基本元素类型一致。因此，除了对数组元素的类型做对齐外外，数组没有其他的对齐需求。这样可以使数组里面的所有成员都是自然对齐的。 



### 强制类型转换引起的对齐问题

因为编译器“透明”地处理了绝大多数的对齐问题，所以要找到潜在错误时会比较困难。然而，在处理指针和强制类型转换时，这样的错误并不少见。

假设一个指针从一个较少字节对齐的类型 char 强制类型转换为一个较多字节对齐的类型 unsigned long，当通过这样的指针来访问数据时，会导致处理器不能对较多字节类型的数据正确对齐：
>
```
  char str[] = "Hello";
  char *c = str[];
  unsigned long a = *(unsigned long *) c;
```

unsigned long 类型通常是 4 字节或 8 字节自然对齐，而 char 以 1 字节自然对齐。因此，当 c 被强制类型转换后，再加载 c 会导致破坏自然对齐。这种问题导致的后果，在不同的系统上各有不同，小者是性能损失，大者是整个程序崩溃。对于可以发现而不能处理对齐错误的体系结构，内核会想破坏对齐的进程发送 SIGBUS 信号，终止该进程。



### 严格别名

类型转换示例也破坏了严格别名规则，严格别名是 C C++ 中最不被了解的部分。严格别名要求一个对象只能通过该对象的实际类型来访问，包括类型的修饰符（如 `const` `volatile`）、实际类型的 `signed` `unsigned` 修饰符、包含实际类型作为成员变量的结构体或联合体，或者 char 类型指针。比如，访问 uint32_t 的一种常见方式是通过两个 uint16_t 指针，这就破坏了严格别名规则。

间接引用把一个变量类型转换成另一个类型的指针往往会破坏严格别名规则。如果你看到如下的 GCC 警告信息 “dereferencing type-punned pointer will break strict-aliasing rules”，就是破坏了这个规则。   

###

## 内存锁定

### 何谓内存锁定？

请求页面调度可以在需要时将页面从磁盘交换进来，当不再需要时再交换出去。这使得系统中进程的虚拟地址空间与实际的物理内存大小没有直接的关系，同时磁盘上的交换空间提供一个拥有近乎无限物理内存的假象。

对应用而言，交换是透明的，应用程序一般不需要关心内核页面调度的行为。然而，在下面两种情况下，应用程序可能希望能够影响系统的页面调度：



### 确定性

时间约束严格的应用程序需要自己来决定页的调度行为。如果一些内存操作引起了页错误--这会导致昂贵的磁盘操作--应用程序可能会超出要求的运行时间。如果能确保需要的页总在内存中并且从不被交换进磁盘，应用程序就能保证内存操作不会导致页错误，提供一致的、可确定的程序行为，从而提供了效能。



### 安全性

如果内存中含有私人信息，这些信息可能最终被页面调度以不加密的方式储存到硬盘上。例如，一个用户的私钥正常情况下是以加密的方式保存在磁盘上的，然而一个在内存中未加密的密钥备份最后可能保存在了交换文件中！！！在一个高度注重安全性的环境中，这么做可能是不可接受的。这样的应用程序可以请求将密钥一直保留在物理内存上。



### 内存锁定的问题

当然，改变内核的行为可能会对系统整体的表现产生负面的影响。应用的确定性和安全性可能会提高，但是由于该应用的页被锁在了内存中，那么另一个应用的页就只能被换出内存。内核（算法）总是换出＂最优页＂（那些在未来最不可能被访问的页）。因此，如果改变了内核的行为，那么它就只能将一个次优的页换出了。

因为锁定内存会影响系统地整体性能--如果太多的页面被锁定，内存分配会失败--Linux 对一个进程能锁定的页面数进行了限制。拥有 `CAP_IPC_LOCK` 权限的进程可以在内存中锁定任意数量的页，没有这个权限的进程只能锁定`RLIMIT_MEMLOCK` 个字节，默认是 `32KB` 。

POSIX.1b 标准定义了两个接口，可以将一个或多个页面＂锁定＂在物理内存，以保证它们不能被交换到磁盘。

###

## IO 调度器

### 磁盘寻址

磁盘性能最糟糕的部分在于把读写磁头从磁盘的一个位置移动到另一个位置，该操作称为＂查找定位＂。单次磁盘查找定位平均需要 8ms 以上 --- 这个值虽然不大，但是却是 CPU 周期的 2500 万倍。

如果每次有 IO 请求时，都按序把这些 IO 请求发送给磁盘，效率就会非常低下。因此，现代操作系统内核实现了 IO 调度器，通过操纵 IO 请求的服务顺序以及服务时间点，最大程度减少磁盘寻址次数和移动距离。IO 调度器尽力将磁盘访问的性能损失控制在最小。



### IO 调度器

IO 调度器实现两个基本操作：合并和排序。

合并操作是将两个或者多个相邻的 IO 请求的过程合并为一个。考虑两次请求：第一次读取第 5 号物理块，第二次读取第 6 号和第 7 号物理块上的数据。这些请求被合并为一个对块 5 到块 7 的操作。总的 IO 吞吐量可能一样，但是 IO 的次数减少了一半。

排序操作是选取两个操作中相对最重要的一个，并按块号递增的顺序重新安排等待的 IO 请求。比如说，IO 操作要求访问块 52、109、7，IO 调度将这三个请求以 7、52、109 的顺序进行排序。如果还有一个请求要访问 81，它将被插入到访问 52 和 109 的中间。然后，IO 调度器按它们在队列中的顺序统一调度：7、52、81、109。按这种方式，磁头的移动距离最小。磁头以平滑、线性的方式移动，而不是无计划的移动（在整个磁盘中来回无序的移动进行查找）。因为磁盘寻址是 IO 操作种代价最高的部分，改进该操作可以使 IO 性能获得提升。



### 改进读请求

每次读请求必须返回最新的数据。因此，当请求的数据不在页缓存中时，读请求在数据从磁盘读出前一直会阻塞---这可能是一个相当漫长的操作。这种性能损失称为＂读延迟＂。

一个典型的应用可能在短时间发起多个 IO 读请求。由于每个请求都是同步的，后面的请求会依赖于前面请求的完成。比如，假设我们要读取一个目录下所有的文件。应用汇打开第一个文件，读取一块数据，等待，然后再读下一段数据，如此往复，直到读完整个文件。然后，该应用开始读取下一个文件。所有的请求都是串行进行的：只有当前请求结束后，后续请求才可以执行。

这和写请求形成了鲜明的对比：写请求在短时间内不需要发起任何 IO 操作。从用户空间应用角度看，写操作请求的是数据流，不受磁盘性能的影响。这种数据流行为只会影响读操作：写数据流会占用内核和磁盘资源。这被称为＂写饿死读＂问题。

如果 IO 调度器总是以插入方式对请求进行排序，可能会＂饿死＂（无限期延迟）块号值较大的访问请求。下面，我们再来看一下之前的例子。如果新的请求不断加入，比如都是 50~60 间的，第 109 块的访问请求将一直不会被调度到。读延迟的问题很严重，可能会极大影响系统性能。因此，IO 调度器采用了一种机制，可以避免＂饿死＂问题。



### IO 调度器算法

最简单的方法就是像 Linux 2.4 那样，采用 Linus 电梯调度法。在该方法中，如果队列中有一定数量的旧的请求，则停止插入新的请求。这样整体上可以做到平等对待每个请求，但在读的时候，却增加了读延迟。问题在于这种检测方法太简单，2.6 内核丢弃了 linus 电梯调度算法，转而使用几种新的调度器算法。

* Deadline IO 调度器
* Anticipatory IO 调度器
* CFQ IO 调度器
* Noop IO 调度器

*/sys/block/device/queue/schedular* 文件用于配置 IO 调度器 deadline、as、cfq、noop。

使用 CFQ 调度器时，每个进程有自己的队列，每个队列分配一个时间片。IO 调度程序使用轮训方式访问并处理队列中的请求，直到队列的时间片耗尽或者所有的请求都被处理完。后一种情况，调度器将会空间一段时间，默认 10ms，等待当前队列中新的请求。如果预测成功，IO 调度器避免了查找操作。如果预测无效，调度程序转而处理下一个进程的队列。

在每个进程的队列中，同步请求（例如读操作）被赋予比非同步请求（例如写操作）更高的优先级。在这种情况下，CFQ 更希望进行读操作，也避免了＂写饿死读＂问题。由于提供了进程队列设置，CFQ 调度器对所有进程都是公平的，同时全局性能也能优。

CFQ 调度器适合大多数的应用场景，是很多情况下的最佳选择。

###

## 页缓存

### 何谓页缓存？

页缓存是通过内存保存最近在磁盘文件系统上访问过的数据的一种方式。相对于当前的处理器速度而言，磁盘访问速度过慢。通过在内存中保存被请求数据，内核后续对相同数据的请求就可以直接从内存读取，避免了重复访问磁盘。



### 缓存和交换

页缓存利用了＂时间局部性＂原理，它是一种＂引用局部性＂，认为刚被访问的资源在不久后再次被访问的概率很高。在第一次访问时对数据进行缓存，虽然消耗了内存，但避免了后续待价很高的磁盘访问。

内核查找文件系统数据时，会首先查找页缓存。只有在缓存中找不到数据时，内核才会调用储存子系统从磁盘读取数据。因此，第一次从磁盘中读取数据后，就会保存到页缓存中，应用在后续读取时都是直接从缓存中读取并返回。页缓存上的所有操作都是透明的。

页缓存大小是动态变化的。随着 IO 操作把越来越多的数据存储到内存中，页缓存也变得越来越大，消耗掉空闲的内存。如果页缓存最终消耗掉了所有的空闲内存，而且有新的请求要求分配内存，页缓存就会被＂裁剪＂，释放掉最少使用的页，让出空间给＂真正的＂内存使用。这种＂裁剪＂是无缝自动处理的。通过这种动态变换的缓存，操作系统可以使用所有的系统内存，并缓存尽可能多的数据。

一般来说，把进程内存中很少使用的页缓存＂交换 swap＂给磁盘要比清理经常使用的页缓存更有意义，因为如果清理掉经常使用的，下一次读请求时又得把它读到内存中。（交换支持内核在磁盘上存储数据，得到比物理内存 RAM 更大的内存空间）。（Linux）内核实现了一些启发式算法，来平衡交换数据和清理页缓存（以及其他驻存项）。这些启发式算法可能会决定通过交换数据到磁盘来代替清理页缓存，尤其当被交换的数据没有在使用时。

＂缓存-交换＂之间的平衡可以通过 */proc/sys/vm/swappiness* 来调整。虚拟文件数可以是 `0` 到 `100`，默认值是 `60`。值越大，表示优先保存页缓存，交换数据；值越小，表示优先清理页缓存，而不是交换数据。



### 预读

另一种引用局部性是＂空间局部性＂，认为数据往往是连续访问的。基于这个原理，内核实现了页缓存预读技术。预读是指在每次读请求时，从磁盘数据中读取更多的数据到页缓存中---实际上，就是多读几个比特。当内核从磁盘中读取一块数据时，它还会读取接下来一两块数据。一次性读取较大的连续数据块会比较高效，因为减少了磁盘寻址。如果进程继续对接下来连续块提交新的读请求，内核就可以直接返回预读的数据，而不用再发起磁盘 IO 请求。

内核对预读的管理也是动态变化的。如果内核发现一个进程一直使用预读的数据，它就会增加预读窗口，从而预读进更多的数据。预读窗口最小 `16KB`，最大 `128KB`。繁殖，如果内核发现预读没有带来任何有效命中---也就是说，应用随机读取文件，而不是连续读---它可以把预读完全关闭掉。

###

## 页回写

### 何谓页回写？

内核通过缓冲区来延迟写操作。当进程发起写请求，数据被拷贝到缓冲区，并将该缓冲区标记为＂脏＂缓冲区，这意味着内存的中的拷贝比磁盘上的新。此时，写请求就可以返回了。如果后续对同一份数据块有新的写请求，缓冲区就会更新成新的数据。对该文件中其他部分的写请求则会开辟新的缓冲区。

最后，那些＂脏＂缓冲区需要写到磁盘，将磁盘文件和内存数据同步。这个过程就是所谓的＂回写＂。以下两个情况会触发回写：

* 当空闲内存小于设定的阈值时，＂脏＂缓冲区就会回写到磁盘上，这样被清理的缓冲区会被移除，释放内存空间。
* 当＂脏＂缓冲区的时长超过设定的阈值时，该缓冲区就会回写到磁盘上。通过这种方式，可以避免数据一直是＂脏＂数据。

回写是由一组称为 **flusher** 的内核线程来执行的。当出现以上两种场景之一时，**flusher** 线程被唤醒，并开始将＂脏＂缓冲区写到磁盘，直到不满足回写的触发条件。

可能存在多个 **flusher** 线程同时执行回写。多线程是为了更好地利用并行，避免拥塞。

缓冲区在内核中是通过 `buffer_head` 数据结构来表示的。该数据结构跟踪和缓冲区相关的各种元数据，比如缓冲区是否是＂脏＂缓冲区。同时，它还维护了一个指向真实数据的指针。这部分数据保存在页缓存中。通过这种方式，实现了缓冲自系统和页缓存中间的统一。



### 页回写的问题

延迟写和缓冲子系统使得写操作性能很高，其代价是如果电源出现故障，可能会丢失数据。为了避免这种风险，关键应用可以使用同步 IO 来保证。

###

## IO 模型

### 一切皆文件

UNIX 系统遵循一切皆文件的理念，其 IO 操作具有通用性的特点。系统调用 `open()` `read()` `write()` `close()` 可以对所有类型的文件进行 IO 操作，包括终端设备。需要访问文件系统或设备的专有功能时，可以使用系统调用 `ioctl()`，它为通用 IO 模型外的专有特性提供了访问接口。 



### 文件表

在对文件进行读写操作之前，首先要打开文件。内核为每个进程维护一个打开文件的列表，称为＂文件表＂。文件表由一些非负整数进行索引，这些非负整数称为＂文件描述符＂。＂文件表＂的每一项记录一个打开文件的信息，包括执行该文件索引节点（inode）的指针以及关联的元数据，如文件偏移量、状态标志等。用户空间和内核空间都使用＂文件描述符＂作为唯一标识：打开文件会返回＂文件描述符＂，而后续操作（读写等）都把＂文件描述符＂作为基本参数。



### 文件描述符

对内核而言，所有打开的文件都通过＂文件描述符＂引用。＂文件描述符＂使用 `int` 类型表示，范围是`0` ~ `OPEN_MAX - 1`（默认是 `1024`，但可以进行配置，最大为 `1048576`）。对于 FreeBSD 8.0，Linux 3.2.0，Mac OS X 10.6.8，Solaris 10，这个范围几乎是无限的，只受到系统配置的存储器总量，整形字长和系统管理配置的约束。


```
  #include <unistd.h>
  printf("%ld", sysconf(_SC_OPEN_MAX));    // Linux 3.2 默认是 1024
```



### 标准输入、标准输出和标准错误

按照惯例，每个进程都至少包含三个＂文件描述符＂，除非显示关闭这些描述符。UNIX shell 把 `0` 与进程的标准输入关联，`1` 与标准输出关联，`2` 与标准错误关联。在 `<unistd.h>` 中定义了常量值 `STDIN_FILENO` `STDOUT_FILENO` `STDERR_FILENO` 以提高可读性。


<table>
<tr>
  <th class="ta-c">文件描述符号码</th>
  <th class="ta-c">用途</th>
  <th class="ta-c">POSIX 名称</th>
  <th class="ta-c">stdio 流</th>
</tr>
<tr>
  <td class="ta-c">`0`</td>
  <td class="ta-c">标准输入</td>
  <td class="ta-c">`STDIN_FILENO`</td>
  <td class="ta-c">`stdin`</td>
</tr>
<tr>
  <td class="ta-c">`1`</td>
  <td class="ta-c">标准输出</td>
  <td class="ta-c">`STDOUT_FILENO`</td>
  <td class="ta-c">`stdout`</td>
</tr>
<tr>
  <td class="ta-c">`2`</td>
  <td class="ta-c">标准错误</td>
  <td class="ta-c">`STDERR_FILENO`</td>
  <td class="ta-c">`stderr`</td>
</tr>
</table>



### 文件关系

UNIX 系统支持在不同进程间共享打开的文件，称之为＂文件共享＂。内核为此维护 3 个数据结构：

* 内核为每个进程维护一个＂文件描述符表＂，记录了文件描述符的相关信息：

  * ＂文件描述符标志＂ - 目前，只定义了一个 `close-on-exec`）
  * ＂打开文件表＂的地址

* 内核为所有打开的文件维护一个＂打开文件表＂，记录了打开文件相关的全部信息：

  * 打开文件时的＂状态标志＂ - 即 `open()` 的 `flags` 参数）
  * 当前文件＂偏移量＂ - 调用 `read()` `write()` 时更新，或者使用 `lseek()` 直接修改
  * 文件访问模式 - 如调用 `open()` 设置的只读、只写、读写模式
  * 与信号驱动 IO 相关的设置
  * 该文件 ＂vnode 表＂的地址 - Linux 没有使用＂vnode 表＂，而是使用＂inode 表＂

* 每个打开的文件（或设备）有一个 vnode 结构，包含了文件类型、对此文件进行各种操作函数的地址。对大多数文件，还包含了该文件的 inode（索引节点） 地址。这些信息是在打开文件时，从磁盘读入内存的。在 Linux 系统中则是直接使用 inode 结构（合并了传统的 vnode 和 inode），包含如下信息：

  * 文件类型 - 普通文件、目录、符号链接、字符设备、块设备、IFO、套接字
  * 访问权限
  * 文件持有的锁地址的列表
  * 文件属性 - 包括文件大小、与不同类型操作相关的时间戳
  * 实际数据块在磁盘上的位置
  * ...

![fs](/images/posix/os_fs.png)

1. 进程 A 的＂文件描述符＂ 1 和 20 指向同一个＂打开文件表＂记录（共享文件偏移量），这很可能是调用`dup()` `dup2()` `fcntl()` 形成的。

2. 进程 A 的＂文件描述符＂ 2 和 进程 B 的＂文件描述符＂ 2 指向同一个＂打开文件表＂记录（共享文件偏移量），这很可能是调用 `fork()` 形成的，或者通过 UNIX 域套接字传递＂文件描述符＂形成的。

3. 进程 A 的＂文件描述符＂ 0 和 进程 B 的＂文件描述符＂ 3 指向不同的    ＂打开文件表＂记录，＂打开文件表＂记录指向同一个＂i-node 表＂，这很可能是不同进程调用 `open()` 形成的，同一个进程两次打开同一文件也会发生类似情况。



### 非阻塞 IO

调用 `open(pathname, flags, mode)` 打开文件时指定 `O_NONBLOCK`，有两个目的：

* 如果 `open()` 未能立刻打开文件，则返回错误，而非陷入阻塞。有一种情况例外：调用 `open()` 操作 FIFO 可能会陷入阻塞。

* 调用 `open()` 成功后，后续的 IO 操作也是非阻塞的：如果 IO 操作未能立刻完成，则不等待，而是立刻返回错误，并将 `errno` 置为 `EAGAIN` 或者 `EWOULDBLOCK`。

调用 `fcntl(fd, F_SETFL, O_NONBLOCK)` 也能把后续 IO 操作修改为非阻塞的。



### 对文件的并发访问

同一个文件可以由一个进程或者多个进程多次打开。内核位每个打开的文件实例提供唯一的文件描述符。因此，进程可以共享文件描述符，支持多个进程使用同一个文件描述符。对文件并发访问的结果取决于不同进程操作的顺序，通常是不可预测的。用户空间的程序往往需要自己协调，确保对文件的同步访问是合理的。



### 原子操作和竞争条件

所有系统调用都是以原子操作方式执行的，内核保证系统调用内部的所有步骤作为独立的操作一次性执行，期间不会为其它进程或者线程所中断。原子性规避了数据竞争。

操作共享资源的两个进程或者线程，其结果是无法预期的，由其所获得　CPU 使用权的先后顺序来决定。这就导致了数据修改的竞争。

调用 `open("foo", O_WRONLY | O_EXCL | O_CREAT)` 打开文件时，同时指定 `O_EXCL` `O_CREAT`，如果文件已经存在会返回一个错误。这使得文件创建和文件存在检查一定是一个原子操作。

调用 `open("foo", O_WRONLY | O_APPEND)` 确保每次一定在文件尾端写是一个原子操作。

###

## 读文件

### 如何读？

每次调用 `read(fd, buf, len)`，会从文件的当前偏移开始读取最多 `len` 字节到 `buf`。执行成功时，返回写入 `buf` 的字节数；出错时，返回 `-1`，并设置 `errno` 值。文件位置指针会向前移动，移动的长度由实际读到的字节数决定。如果文件不支持 seek 操作（比如字符设备文件），则读操作总是从＂当前位置＂开始。



### 部分读

有多种情况，可能出现实际读到的字节数 < 要求读的字节数：

* 读普通文件时，在读到要求字节数之前已经到达了文件尾端。比如，要求读 100 个字节，但是到达尾端时，只有 30 个字节。下一次再调用 `read()` 时，将返回 `0`（文件尾端）。
* 读终端设备时，通常一次最多读一行。
* 读网络时，网络的缓冲机制可能造成返回值小于要求读的字节数。
* 读管道或者 FIFO 时，如果包含的字节少于要求读的字节数，`read()` 只返回实际可用的字节数。
* 读某些面向记录的设备（磁带）时，一次最多返回一个记录。
* 当一信号造成中断，而已经读了部分数据量时。



### 返回值

* result == `len`，读取到预期的字节。
* `0` < result < `len`，读取到部分字节。原因有多种，比如：
  * 读取过程中信号中断
  * 读取出错
  * 可读的数据小于 `len` 大于 `0`，读取 `len` 字节前到达 EOF。再次 `read` 会读取剩余的字节或者给出错误信息
* result == `0`，表示 EOF，没有更多可读的数据。
* result == `-1`，把 `errno` 置为 `EINTR`，表示读取任何字节前收到信号。再次调用 `read()` 可以重新执行。
* result == `-1`，把 `errno` 置为 `EAGAIN` （Linux） 或者 `EWOULDBLOCK` （BSD），表示当前没有数据可用，读操作会阻塞，应该稍后再重新调用 `read()`。只在非阻塞模式下发生。
* result == `-1`，把 `errno` 置为非 `EINTR` `EAGAIN` `EWOULDBLOCK` 的值。表示更严重的错误，重新调用 `read()` 不会成功。<br /



### 非阻塞读

有时，开发人员不希望 read() 调用在没有数据可读时阻塞在那里。相反地，希望调用立即返回，表示没有数据可读。这种方式称为＂非阻塞 IO＂。它支持应用以非阻塞模式执行 IO 操作，当读取多个文件时，以防错过其他文件中的可用数据。管道，FIFO，Socket，设备（比如终端，伪终端）都支持非阻塞模式。

当以非阻塞模式打开，并且没有数据可用，`read()` 调用会返回 `-1`，并设置 `errno` 为 `EAGAIN` （Linux） 或者`EWOULDBLOCK` （BSD）。      

###

## 写文件

### 如何写？

调用 `write(fd, buf, len)` 从文件的当前偏移开始，将 `buf` 中最多 `len` 个字节写入到文件中。不支持 `seek` 的文件（如字符设备文件）总是从起始位置开始写。执行成功时，返回写入的字节数，并更新文件位置；出错时，返回 `-1`，并设置 `errno` 值。



### 追加写

`O_APPEND` 保证了文件偏移量总是位于文件尾端，即使存在多个写进程，所有的写操作还是能够保证是追加写。



### 部分写

对于普通文件，除非发生错误，`write()`会保证执行整个写请求，不需要执行循环写操作。但是，对于其他文件类型，比如套接字，需要循环来保证写了所有请求的字节（比如管道的缓冲区填满，没有消费者）。使用循环的另一个好处是，第 2 次调用可能返回错误值，说明上一次调用为什么只执行了部分写（虽然这种情况并不常见）。



### 非阻塞写

以非阻塞模式打开文件，当发起写操作时，系统调用返回 `-1`，并设置 `errno` 值为 `EAGAIN` （Linux） 或者`EWOULDBLOCK` （BSD）。一般而言，对于普通文件，不会出现这种情况。 

###

## 文件偏移量

### 何谓文件偏移量？

一般情况下，IO 是线性的。对于每个打开的文件，内核会为其记录＂文件偏移量＂，有时也将文件偏移量称为＂文件位置＂。文件偏移量是指执行下一个读写操作的文件起始位置，以相对于文件头部起始点的当前位置来表示。

通常，读写操作都从＂文件偏移量＂处开始，并使偏移量增加读写的字节数。默认情况下，打开一个文件时，除非指定 `O_APPEND`，否则＂偏移量＂置为 0。＂文件偏移＂还可以手动设置给定值，该值甚至可以超出文件结尾。超出文件结尾追加字节会使得中间字节（文件结尾到数据之间）被填充为 0，称为＂空洞＂。在文件中间位置写入字节会覆盖该位置原来的数据。因此，在中间写入数据并不会导致原始数据向后偏移。



### 文件偏移量的大小

＂文件偏移量＂以 `off_t` 类型表示，定义在 `<unistd.h`，允许具体实现的平台自己选择大小合适的数据类型。现今大多数平台提供两组接口，一组使用 32 位文件偏移量，一组使用 64 位文件偏移量。

SUS 提供了一种方法，通过 `sysconf(_SC_NAME)` 可以确定平台支持何种环境：

选项|描述|name 参数
-|-|-
_POSIX_V7_ILP32_OFF32|`int` `long` `指针` `off_t` 是 32 位|`_SC_V7_ILP32_OFF32`
_POSIX_V7_ILP32_OFFBIG|`int` `long` `指针` 是 32 位，`off_t` 是 64 位|`_SC_V7_ILP32_OFFBIG`
_POSIX_V7_ILP64_OFF64|`int` 是 32 位，`long` `指针` `off_t` 是 64 位|`_SC_V7_ILP64_OFF64`
_POSIX_V7_ILP64_OFFBIG|`int` 是 32 位，`long` `指针` `off_t` 是 64 位|`_SC_V7_ILP64_OFFBIG`



### 空洞

如果＂文件偏移量＂已经跨越了文件结尾，再次执行 IO 操作时，`read()` 将返回 `0`，表示文件结尾；`write()` 则可以在文件结尾后任意位置写入数据。

文件结尾到新写入的数据间的空间，称为＂文件空洞＂。读取空洞将返回以 0 （空字节）填充的缓冲区。然而，＂文件空洞＂不占用任何磁盘空间。直到后续在文件空洞中写入了数据，文件系统才会为其分配磁盘块。空洞的存在意味着，一个文件名义上的大小可能比实际占用的磁盘存储总量要大。向＂文件空洞＂写入字节，内核需要为其分配存储单元，即便文件大小不变，但是系统可用磁盘空间也将减少。



### 不适用的文件类型

`lseek(fd, offset, origin)` 并不适用于管道、FIFO、套接字或终端。一旦如此，调用会失败，并将 `errno` 置为 `ESPIPE`。

###

## 文件长度

### 何谓文件长度？

文件的大小通过字节计算，称为文件长度。

### 文件截断

系统调用 `ftruncate(pathname, length)` `truncate(fd, length)` 可以改变给定文件的长度。即可以减小长度，剩余的数据不能再访问；也可以增加长度，增加的空间使用 0 填充为＂文件空洞＂。

###

## 复制文件描述符

### 如何复制文件描述符？

UNIX 系统支持在不同进程间共享打开的文件。`dup()` `dup2()` 都可用来复制一个现有的文件描述符，用于共享文件。

每个＂文件描述符＂都有自己的一套＂文件描述符标志＂。返回的＂新文件描述符＂的 ｀close-on-exec｀ 总是由 `dup()` 清除。返回的＂新的文件描述符＂，与 `fd` 共享同一个＂打开文件表＂记录。



### /dev/fd

较新的系统提供 */dev/fd/* 的目录，其目录项是 0 1 2 等文件。打开 */dev/fd/n* 等效于复制＂文件描述符 n＂（假定 n 是打开的）：


```
  fd = open("/dev/fd/0", mode);  // 等效于 fd = dup(0)，0 和 fd 共享同一文件表项
```

*/dev/fd/* 主要由 **shell** 使用： `$ filter file2 | cat file 1 /dev/fd/0 file3 | lpr`，**cat** 读取 file1，然后读取标准输入 filter file2 的结果，然后读取 file3，最后输出到 **lpr**。

###

## 同步

### 如何同步？

为了确保数据写入磁盘，最简单的方式是使用系统调用 `fsync()` `fdatasync()` `sync()`。



### fsync

`fsync()` 可以确保和文件描述符相关文件的所有脏数据都会回写到磁盘上。该调用会会写数据和元数据，如创建的时间戳以及索引节点中的其他属性。该调用在硬盘驱动器确认数据和元数据已经全部写到磁盘之前不会返回。可用于数据库这样的程序，确保修改过的块立刻写到磁盘上。



### fdatasync

`fdatasync()` 和 `fsync()` 相似，区别在于 `fdatasync()` 只会写入数据以及以后要访问文件所需要的元数据（比如文件大小），但是不保证非基础的元数据也写到磁盘上。因此一般而言，它执行更快。对于大多数使用场景，除了最基本的事务外，不会考虑元数据如文件修改时间戳，因此 `fdatasync()` 就能够满足需求，而且执行更快。



### sync

`sync()` 用来对磁盘上的所有缓冲区进行同步。POSIX 标准并不要求 `sync()` 一直等待所有缓冲区都写到磁盘后才返回，只需要调用它来启动把所有缓冲区写到磁盘上即可。因此，一般建议多次调用 `sync()`，确保所有数据都安全写入磁盘。但是对于 Linux 而言，`sync()` 一定是等到所有缓冲区都写入了才返回，因此调用一次就够了。通常，称为 **update** 的系统守护进程，会周期性的调用（一般每隔 30 秒） `sync()`，保证定期冲洗内核的块缓冲区。    

### 带缓存的硬盘

对于包含写缓存的硬盘，`fsync()` `fdatasync()` `sync()` 无法知道数据是否已经真正在无力磁盘上了。硬盘会报告说数据已经写完了，但是实际上数据还在硬盘驱动器的写缓存上。好在，在硬盘驱动器缓存中的数据会很快写入到磁盘山。   

###

## 关闭文件

系统调用 `close(fd)` 会取消当前进程的＂文件描述符＂与其关联的文件之间的映射。调用后，先前给定的＂文件描述符 fd＂不再有效，内核可以随时重用它。

关闭文件操作并非意味着该文件的数据已经被写到磁盘。如果应用希望保证关闭文件之前数据已经写入磁盘，使用同步调用。

## 拷贝和移动文件

两个最基本的文件处理任务是拷贝和移动文件，往往是通过 **cp** 和 **mv** 来实现。

UNIX 并不包含实现多文件和目录拷贝的系统调用，相反，需要手工执行 **cp** 或者 GNOME's Nautilus 文件管理器这类工具来完成这些功能。



### 拷贝文件

要拷贝文件 src，生成文件 dst，需要执行以下步骤：

1. 打开 src 。
2. 打开 dst，如果 dst 不存在则创建，如果已存在则把长度截断为 0 。<br /
3. 把 src 数据块写入 dst 。
4. 把该数据块写入 dst。
5. 继续操作直到 src 全部读取完并且已经都写入到 dst 中。
6. 关闭 dst。
7. 关闭 src。

如果是拷贝的目录，则通过 `mkdir()` 创建目录及其所有子目录，并单独拷贝其中的每个文件。



### 移动文件

和拷贝文件不同，UNIX 提供了移动文件的系统调用 `rename(oldname, newname)`。类似 `mv` 的工具通过调用拷贝和解除链接来完成 `rename()` 操作。

###

## 监视文件事件

某些应用需要对文件或者目录进行监控，以侦测其是否发生了特定事件。

通过 `inotify()`，内核能在事件发生时把时间推送给应用程序。

许多应用关注文件事件，比如备份工具和数据索引工具，`inotify()` 能够确保这些程序的实时操作：在创建、删除或者写入文件时，可以立刻更新备份或数据索引。

## 流 IO

### 逻辑块对齐

对非整数倍＂逻辑块＂大小的操作效率很低，操作系统需要对 IO 进行＂修补＂，确保所有操作都实在块大小整数倍上执行，并且和下一个最大块对齐。频繁的系统调用所带来的开销会导致操作性能急剧下降。举个例子，假设要读取 1024 个字节，如果每次度一个字接需要执行 1024 次系统调用，而如果一次读取 1024 字节的块则只需要执行 1 次系统调用。对于前一种，提升其性能的途径是＂用户缓冲 IO＂，通过缓冲 IO，从用户角度，读写数据并没有任何变化，而实际上，只有当数据量大小达到文件系统＂逻辑块＂大小的整数倍时，才会执行真正的 IO 操作。



### 用户缓冲 IO

用户缓冲 IO 是在用户空间而不是内核空间完成的，可以在应用程序中设置，也可以调用标准库，对用户而言＂透明＂
执行。出于性能考虑，用户缓冲 IO 也如同内核通过延迟写、合并相邻 IO 请求以及预读等操作来缓冲数据。

把每次操作的数据设置为＂逻辑块＂大小整数倍，可以保证 IO 请求是块对齐的，从而避免内核的冗余操作，实现最大规模的效率提升。最简单的方式是设置一个较大的用户缓冲区，大小设置成 `4096B` `8192B` 性能都不错。



### 操作过程

应用使用自己的抽象结构，通过用户缓冲 IO，实现块操作。

当数据写入时，会被存储到用户空间的缓冲区中。当缓冲区数据大小达到给定值，即缓冲区大小，整个缓冲区会通过一次写操作全部写出。同样，读操作也是一次读入缓冲区大小且块对齐的数据。应用的各种大小不同的读请求，不是直接从文件系统读取，而是从缓冲区中一块块读取。应用读取的数据越来越多，缓冲区一块块给出数据。

通过这种方式，虽然应用设置的读写大小很不合理，数据会从缓冲区中获取，因此对文件系统仍然发送大的块对齐的读写请求。其最终结果是对于大量数据，系统调用次数更少，切每次请求的数据大小都是块对齐的，通过这种方式，可以确保有很大的性能提升。



### 流定向

对于 ASCII 字符集，一个字符用一个字节表示。对于国际字符集，一个字符用多个字节表示。标准 IO 文件流可用于单字节或者多字节（宽字节）字符集。流的定向决定了所读写的字符是单字节还是多字节的。当一个流最初被创建时，没有定向。在未定向的流上：

* 如果使用一个多字节 IO 函数（`<wchar.h>`），则将该流的定向设置为＂宽定向＂的。
* 如果使用一个单字节 IO 函数，则将该流的定向设置为＂字节定向＂的。<br/>



### 流缓冲区

标准 IO 实现了三种类型的用户缓冲，并为开发者提供了接口，可以控制缓冲区类型和大小：

<table>
<tr>
  <td style="min-width:55px;">块缓冲</td>
  <td>在填满标准 IO 的缓冲区后才进行内核缓冲区的 IO 操作。缓冲区可由标准 IO 例程自动冲洗（比如填满一个缓冲区时），或者直接调用 `fflush()` 立刻冲洗。</td>
</tr>
<tr>
  <td>行缓冲</td>
  <td>在输入和输出中遇到换行符时，标准 IO 库执行内核缓冲区的 IO 操作。当流涉及一个终端时（比如仿真终端标准输入和标准输出），通常使用行缓冲。因为标准 IO 库的缓冲区长度是固定的，因此只要填满缓冲区，即使还没有写一个换行符，也进行 IO 操作。</td>
</tr>
<tr>
  <td>无缓冲</td>
  <td>标准 IO 库不对字符进行缓冲存储。</td>
</tr>
</table>



### 很多系统的默认缓冲

* 标准错误是无缓冲
* 如果流指向终端设备，则是行缓冲，否则是块缓冲



### stdin stdout stderr

标准 IO 库 `<stdio.h>` 处理许多细节，比如缓冲区分配，优化块长度，执行 IO 等。其中 `stdin` `stdout` `stderr` 定义在 `<stdio.h>`，与 `STDIN_FILENO` `STDOUT_FILENO` `STDERR_FILENO` 引用的文件相同。



### 打开流

标准 IO 库通过 `FILE` 指针来操作文件，`FILE` 定义在 `<stdio.h`。打开流将返回一个 `FILE` 指针。



### 冲洗标准 IO 缓冲区

无论当前采用何种缓冲区模式，任何时候都可以使用 `fflush(fp)` 强制将标准 IO 缓冲区中的数据刷新到内核缓冲区中。在关闭流时，也会自动冲洗其标准 IO 缓冲区。



### 读流

一旦打开了流，可使用 3 种不同类型调用读流：

* 每次一个字符
* 每次一行
* 直接 IO 



### 读流返回值判断

流对象 `FIL`E 中维护了两个标志：

* 出错标志
* 文件结束标志

调用 `clearerr()` 可以清除这两个标志。

调用`ferror()` `feof()` 可以区分返回的 `EOF` 是错误还是到达文件尾端。



### 写流

一旦打开了流，可使用 3 种不同类型调用写流：

* 每次一个字符
* 每次一行
* 直接 IO <br / 



### 流偏移量

标准 IO 库也提供了等价于 `lseek()` 定位当前流位置的函数。一把可以使用 `fseek()` `rewind()` `ftell()`。当需要移植到非 UNIX 系统时，应当使用 `fsetpos` `fgetpos`，这两个调用使用一个足够大的数，用来记录文件位置。 



### 关闭流   

`fclose(fp)` 可以关闭流，关闭前，所有被缓冲但还没有写出的数据都会被写出。

此外，当一个进程正常终止（直接调用 `exit()`，或者从 `main()` 返回），所有的标准 IO 缓冲区也会被冲洗，所有打开的标准 IO 流都被关闭。



### 避免条件竞争

访问共享数据时，有两种方式避免修改它：
* 采取数据同步访问机制（加锁）
* 把数据存储在线程的局部变量中，也称为线程封闭



### 标准 IO 和线程安全

标准 IO 本质上是线程安全的。在每个函数的内部实现中，都关联了一把锁、一个锁计数器，以及持有该锁并打开一个流的线程。每个线程在执行任何 IO 请求前，必须首先获得锁而且持有该锁。两个或者多个运行在同一个流上的线程不会交叉执行标准 IO 操作，因此，在单个函数调用中，标准 IO 操作是原子操作。

对于复杂的多进程，可能仍然需要更精细的锁控制。标准 IO 为此提供了一系列函数，每个函数可以操纵和流关联的锁。



### stdio 及其一些替代库

标准 IO 使用广泛，但是也存在一些不足。当读取数据时，会向内核发起 `read()` 系统调用，把数据从内核复制到标准 IO 的缓冲区。当应用通过标准 IO 发起读请求时，又会拷贝数据，从标准 IO 的缓冲区拷贝到指定缓冲区。写入请求正好相反：数据先从指定缓冲区拷贝到标准 IO 缓冲区，然后又通过 `write()` 从标准 IO 缓冲区写入内核。

避免两次拷贝的一个解决办法是，每个读请求返回一个指向标准 IO 缓冲区的指针。这样，数据就可以直接从标准 IO 缓冲区读取，不需要多余的拷贝操作。如果应用确实需要把数据拷贝到自己本地缓冲区时，总是可以手动执行拷贝操作。

写请求会更复杂些，但是还是可以避免两次拷贝。当发起写请求时，记录指针位置，最终当准备将数据刷新到内核时，再通过记录的指针列表把数据写出去。这些可以通过分散-聚集 IO 的 `writev()` 来实现。这样写请求就只需要单个系统调用。

快速 IO 库 fio，sfio 都是较为优秀的效率较好的流 IO 库。不过标准 IO 仍然很流行。   



### 流 IO 适用情景

* 很可能会发起多个系统调用，而希望合并这些调用从而减少开销
* 性能至关重要，希望保证所有 IO 操作都是以块大小执行，从而保证块对齐
* 访问模式是基于字符或行，希望通过接口可以简单的实现这种访问，但有不希望产生额外的系统调用
* 和底层的系统调用相比，更喜欢调用高层接口       

###

## 分散和聚集 IO

### 何谓分散聚集？

分散／聚集 IO 是一种可以在单次系统调用中对多个缓冲区输入输出的方法，可以把多个缓冲区的数据写到单个数据流，也可以把单个数据流读到多个缓冲区中。其命名的原因在于数据会被分散到指定缓冲区向量，或者从指定缓冲区向量中聚集数据。这种输入输出方法也称为“向量 IO”（Vector IO）。与之不同，前面提到的读写系统调用可以称为“线性 IO”。



### 优势

* 编码模式更自然 - 如果数据本身是分段的（比如预定义的结构体变量），向量 IO 提供了直观的数据处理方式。
* 效率更高 - 单个向量 IO 操作可以取代多个线性 IO 操作。
* 性能更高 - 除了减少了发起的系统调用次数，通过内部优化，向量 IO 可以比线性 IO 提供更好的性能。
* 支持原子性 - 和多个线性 IO 不同，一个进程可以执行单个向量 IO 操作，避免了和其他进程交叉操作的风险。



### 向量

在 `readv(fd, iov, count)` `writev(fd, iov, count)` 系统调用中，使用一个或者多个 `struct iovec` 结构体来描述独立的、物理不连续的缓冲区，我们称其为缓冲区段，一组缓冲区段称为“向量”。

每个缓冲区描述了内存中所要填写的缓冲区地址和长度。`readv()` 在处理下个缓冲区之前，会填满当前缓冲区的 `iov_len` 个字节。`writev()` 在处理下个缓冲区之前，会把当前缓冲区所有 `iov_len` 个字节数据输出。这两个调用都会顺序处理向量中的缓冲区，从 `iov[0]` 开始，接着是 `iov[1]`，一直到 `iov[count-1]`。



### 优化 count 值

在向量 IO 操作中，Linux 内核必须分配内部数据结构来表示每段缓冲区。一般来说，是基于 `count` 的大小动态分配进行的。然而，为了优化，如果 `count` 值足够小，内核会在栈上创建一个很小的缓冲区段数组，通过避免动态分配向量内存，从而获得性能上的一些提升。`count` 的阈值一般设置为 `8`，因此如果 `count <= 8`，向量 IO 操作会以一种高效的方式，在进程的内核栈中运行。

大多数情况下，无法选择在指定的向量 IO 操作中一次同时传递多少个缓冲区段，当你认为可以使用一个较小值时，选择 `8` 或更小的值肯定会得到性能的提升。

###

## 多路复用 IO

### 何谓多路复用？

IO 多路复用支持应用同时在多个文件描述符上阻塞，并在其中某个可以读写时收到通知。IO 多路复用在设计上遵循以下原则：

1. IO 多路复用：当任何一个文件描述符 IO 就绪时进行通知。
2. 都不可用？ 在有可用的文件描述符之前一直处于睡眠状态。
3. 唤醒：哪个文件描述符可用了？
4. 处理所有 IO 就绪的文件描述符，没有阻塞。
5. 返回第 1 步，重新开始。



### 方案

许多 UNIX 提供了不同的实现方案，其中以 `select()` 可移植性最好。`poll()` 和 `select()` 完成相同的工作，但是不需要用户计算很大文件描述符值加 1 作为参数，效率也更高。不过有些 UNIX 系统不支持 `poll()` 。

`select()` 和 `poll()` 每次调用都需要所有被监听的文件描述符列表。内核必须遍历所有被监视的文件描述符。当这个文件描述符列表变得很大时---包含几百个甚至几千个文件描述符时---每次调用都要遍历列表就变成规模上的瓶颈。Linux 平台特有的 `epoll()` 和 BSD 平台特有的 `kqueue()` 把监听注册从实际监听中分离出来，从而解决了这个问题。



### 水平触发和边缘触发

水平触发是指当条件满足时触发一个 IO 事件，边缘触发是指当状态改变时触发一个 IO 事件。边缘触发更简单，但是不注意的话很容易丢失 IO 事件。

`select()` `poll()` 采用水平触发，`epoll()` 默认采用水平触发，但是可以通过 `epoll_ctl()` 修改为边缘触发。 

###

## 存储映射 IO

### 何为存储映射？

除了标准文件 IO，内核提供了一个接口，支持应用程序将文件映射到内存中，即内存地址和数据文件一一对应。这样，开发人员就可以直接通过内存来访问文件，就像操作内存中的数据块一样，甚至可以写入内存数据区，然后通过“透明”的映射机制将文件写入磁盘。

POSIX.1 标准定义了 `mmap(addr, len, prot, flags, fd, offset)` 系统调用，实现了在 IO 中将文件映射到内存的功能。



### 优点

* 使用 `read()` `write()` 系统调用时，需要从用户缓冲区进行数据读写，而使用 `mmap()` 映射文件进行操作，可以避免多余的数据拷贝操作。

* 除了可能潜在页错误，读写映射文件不会带来系统调用和上下文切换的开销，它就像直接操作内存一样简单。 

* 当多个进程把同一个对象映射到内存中时，数据会在所有进程间共享。可读和可写共享的映射在全体中都是共享的，私有可写的映射对尚未进行写时拷贝页是共享的。

* 在映射对象中搜索只需要很简单的指针操作，不需要使用系统调用 `lseek()` 。



### 不足

* 由于映射区域的大小总是页大小的整数倍，因此，文件大小与页大小的整数倍之间有空间浪费。对于小文件，空间浪费会比较严重。比如，如果页大小是 `4096B`，一个 `7B` 的映射就会浪费 `4089B` 。

* 存储映射区域必须在进程地址空间内。对于 32 位的地址空间，大量的大小不同的映射会导致生成大量的碎片，使得很难找到连续的大片空内存。当然，这个问题在 64 位地址空间就不是很明显。

* 创建和维护映射以及相关的内核数据结构有一定的开销。不过，由于 `mmap()` 消除了读写时的不必要拷贝，这种开销几乎可以忽略，对于大文件和频繁访问的文件更是如此。

基于以上理由，处理大文件（浪费空间小），或者在文件大小恰好被页大小整除（没有空间浪费）时，`mmap()` 的优势就会非常显著。



### 页大小

页是内存管理单元（MMU）的粒度单位。因此，它是内存中允许具有不同权限和行为的最小单元。页是内存映射的基本块，因而也是进程地址空间的基本块。

`mmap(addr, len, prot, flags, fd, offset)` 系统调用的操作单元是页。参数 addr 和 offset 都必须按页大小对齐。也就是说，它们必须是页大小的整数倍！！！

所以，映射区域是页大小的整数倍。如果调用方提供的 `len` 参数没有按页对齐（可能是因为需要映射的文件大小不是页大小的整数倍），映射区域会一直占满最后一个页。多出来的内存，即最后一个有效字节到映射区域边界这一部分区域，会用 0 填充。该区域的所有操作都将返回 0 。所有写操作都不会影响文件的最后部分，即时使用参数 `MAP_SHARED` 进行映射，只有最前面的 `len` 个字节会写到文件中。

POSIX 标准规定，获得页大小的方法是通过 

*`
  sysconf(_SC__PAGESIZE)
`*



```
#| 
#|                  ×                ×        
#|                  ××××××××××××××××××
#|                  ×    Stack       ×
#|                  ××××××××××××××××××
#|                  ×                ×
#|                  ××××××××××××××××××..................................
#|                  ×   Memory Map   ×                                 .
#|                  ××××××××××××××××××...................              .     
#|                  ×                ×                  .              .
#|                  ××××××××××××××××××                  .              .
#|                  ×     Heap       ×                  .              .
#|                  ××××××××××××××××××         ×××××××××××××××××××××××××
#|                  ×                ×         × offset | 文件的映射区域 ×  
#|                  ×                ×         ×××××××××××××××××××××××××
#|
#|                      进程地址空间                       文件
#|
#|
```

###

## 目录和链接

### 目录

文件通常是通过文件名（而不是索引节点号）从用户空间打开。目录包含一个文件名列表，每个文件名对应一个inode 编号。每个文件名称为目录项，每个名字到 inode 的映射称为链接。目录内容就是该目录下所有的文件名列表。当用户打开指定目录下的文件时，内核会在该目录列表中查找文件名对应的 inode 编号，并将该 inode 编号传递给文件系统。文件系统使用它来寻找文件在设备上的物理位置。

可以把目录看做普通文件，其区别在于目录包含＂文件名称 <--inode＂的映射。内核通过该映射把文件名解析为索引节点！！！

每个目录至少包含两条记录：**.** 和 **..**。**.** 是指向目录自身的链接， **..** 是指向上级目录的链接。除了根目录 */*，每个目录都有父目录。对于根目录 */*， **..** 是指向根目录自身的链接。



### 路径解析

目录可以嵌套到其他目录中，形成目录层。当内核打开类似的路径名时，它会遍历路径中的每个目录项，查找下一个入口项的索引节点。比如 `/home/king/test.js`，起始项是 /，先获取 home 的索引节点，然后获取 king 的索引节点，最后获取 test.js 的索引节点。这个操作称为路径解析。内核也采用缓存储存目录的解析结果，基于＂时间局部性＂原理，可以为后续访问更快的提供查询结果。



### 绝对路径和相对路径

路径名是由文件名和一级或者多级父目录组成。绝对路径名是以根目录启示的路径名，例如 /usr/bin/nginx 。相对路径名是不以根目录起始的路径名，例如 bin/nginx 。为了使路径名有效，操作系统必须知道目录的相对路径，此时使用当前工作目录作为起始点。

除了用于描述路径目录的 '/' 和终止路径名的 '�'，文件和目录名可以包含其他一切字符。较老的 UNIX 系统限制文件名至多 14 个字符，今天所有现在 UNIX 文件系统对每个文件名至少支持 255 个字节。

需要注意的是：文件名限制是 255 个字节，而非 255 个字符。多字节的字符显然一个字符占用多于一个字节。



### 硬链接

目录中每个文件名到 inode 的映射称为链接。根据定义，链接本质上不过是列表（目录）中一个指向 inode 的名字。并没有限制一个 inode 的链接的数目，因此单个 inode 可以同时由 /etc/customs 和/var/run/ledger 指向。

有一点需要注意：因为链接映射至 inode，且不同文件系统的 inode 编号是不同的，/etc/customs 和/var/run/ledger 必须位于同一文件系统。在一个文件系统，指定文件的链接数可以很大。唯一的限制是用来表示链接数的整数数据类型的范围。在所有链接中，没有一个链接是＂原始＂或＂初始＂链接。这些链接都指向同一个文件，并共享文件状态。

我们称这种类型的链接为硬链接。文件的连接数可以是 0、1 或者多个。大多数文件的链接数是 1，但有些文件可能有两个设置多个链接。链接数为 0 的文件在文件系统上没有对应的目录项。当文件链接计数达到 0 时，文件被标记为空闲，其占用的磁盘块就可重用。当进程打开了这样一个文件时，文件仍在文件系统中保留。如果没有进程打开该文件，文件就会被删除。

Linux 内核通过＂链接计数＂和＂使用计数＂来进行管理。使用计数是指文件被打开的实例数的计数。从目录中删除文件，意味着从目录结构中取消链接（unlink）该文件，这只需要从目录中删除文件名和索引节点就可以。然而由于硬链接的原因，文件系统不能对每个 `unlink()` 操作执行删除索引节点和关联数据的操作。为了确保在删除所有的链接之前不会删除文件，每个索引节点都包含链接计数，当 `unlink()` 某个路径时，其链接计数减 1，只有当链接计数为 0 时，索引节点和关联的数据才会从文件系统中真正删除。

只有特权进程才能创建指向目录的硬链接。硬链接支持多个路径指向同一数据，共享同一个 i 表节点。



### 当前工作目录

每个进程都有一个当前目录，一般是在创建时从父进程继承的。内核解析相对路径名时，会把当前工作目录作为起始点。例如，如果进程的当前工作目录是 /home/king，切该进程是图打开 test.js，内核将试着打开/home/king/test.js。

当用户登录时，＂当前工作目录＂通常是从口令文件第 6 个字段得到。进程可以获取并更改其当前工作目录。

###

## 符号链接

### 符号链接

硬链接不能扩越多个文件系统，因为索引节点编号在自己的文件系统外没有任何意义。为了扩越文件系统建立链接，Unix 系统实现了符号链接。  

符号链接，也称为软链接。类似普通文件，每个符号链接有自己的索引节点和数据块，包含要链接的文件的绝对路径。这意味着符号链接可以指向任何地方，包括不同的文件系统上的文件和路径，甚至指向不存在的文件和目录。指向不存在的文件的符号链接称为坏链接。



### 符号链接和硬链接的区别

它和硬连接的相同之处在于二者均指向文件系统中的文件，不同点在于符号链接不会增加额外的目录项，而是一种特殊的文件类型。该文件包含被称为符号链接指向的其他文件（一般成为符号链接的目标文件）的路径名。运行时，内核用该路径名代替符号链接的路径名（除非系统调用是以＂l＂开头，例如 `lstat()`，它操作链接本身而非目标文件）。

另外一个重要的区别是它可以跨越不同的文件系统。实际上，符号链接可以指向任何位置！可以指向已存在或不存在的文件。后者被称为悬空的符号链接（或称无效的符号链接）。有时，悬空的符号链接是指不再需要的---例如当链接目标已删除，但符号链接没有删除时，该符号链接就变成悬空的了---但是，在某些情况下是故意的。符号链接还可以指向其他符号链接，这样就会存在环。处理符号链接的系统调用通过维护最大遍历深度来查看是否存在环。如果超过深度，就返回 `ELOOP` 。
 


### 用处

符号链接通常作为文件访问的快捷方式，而不是作为文件系统内部链接。



### 性能

比起硬链接，符号链接会带来更多的开销，因为解析符号链接需要解析两个文件：符号链接本身和该链接指向的文件。硬链接不会带来这些额外开销：访问在文件系统中被多次链接的文件和单次链接的文件没有区别。

###

## 设备文件

### 何谓设备文件？

设备文件使用 */dev* 目录下的文件来表示，既可以是真实存在的，也可以是虚拟的（模拟），内核都会为其提供设备驱动程序，实现与真实设备相同的 API，便于处理设备的 IO 请求。（设备驱动程序，属于内核代码单元，可以执行一系列的操作，与相关硬件的输入／输出相对应）。每个设备驱动程序，提供的接口都一致，隐藏了设备在操作方面的差异，从而满足 IO 操作的通用性。



### 设备类型

可以将设备划分为 2 种类型：
* 块设备  - 每次处理一块数据。通常是存储设备，比如磁盘，磁带，CD-ROM，闪存
* 字符设备 - 基于每个字符处理数据。比如终端，键盘



### 设备号码

每个设备都有＂主号码＂和＂次号码＂。＂主号码＂标识设备的等级，内核也用＂主号码＂查找对应的设备驱动程序。＂次号码＂用于标识唯一特定设备。



### 特殊设备文件

存在几个特殊的设备文件，对测试程序如何处理特殊问题很有帮助：

* 空设备 - 位于 */dev/null*，＂主号码＂是 1，＂次号码＂是 3。该设备文件的属主是 **root** 但是所有用户均可读写。忽略所有对该设备的写请求，读取该设备会返回文件终止符（`EOF`)。
* 零设备 - 位于 */dev/zero*，＂主号码＂是 1，＂次号码＂是 5。忽略所有对该设备的写请求，读取该设备会返回无限 null 字节流（`'�'`）。
* 满设备 - 位于 */dev/full*，＂主号码＂是 1，＂次号码＂是 2。写请求总是触发 ENOSPC 错误，表明设备已满，读请求返回无限 null 字节流（`'�'`）。

###

## FIFO

FIFO 是以文件描述符作为通信信道的进程间通信（IPC）机制，可以通过特殊文件来访问。普通管道是将一个程序的输出以＂管道＂的方式作为另一个程序的输入。普通管道是通过系统调用在内存中创建的，并不存在于任何文件系统中。FIFO 和普通管道一样，但是它是通过 FIFO 特殊文件来访问的。不相关的进程可以访问该文件进行交互。

## 套接字

### 何谓套接字？

套接字是一种进程间通信机制，允许位于同一主机或者使用网络连接起来的不同主机上的应用程序之间交换数据。



### 使用方式

* `socket()` - 创建一个新的套接字实例，并返回套接字描述符。
* `bind()` - 将一个套接字描述符绑定到一个地址上。通常，服务器需要绑定一个众所周知的地址，以便客户端能够定位到该套接字。
* `listen()` - 允许一个流套接字接受来自其它套接字的连接。
* `accept()` - 在一个流套接字上监听来自其他应用程序的连接，并可选地返回对等套接字地址。
* `connect()` - 和另一个套接字建立连接。



### 流

流式套接字（`SOCK_STREAM`）提供了一个可靠的、双向的字节流通信信道。

* 可靠的 - 表示发送者传输的数据会完整无缺的到达接收应用程序（假设网络连接和接受者都不会崩溃）或者收到一个传输失败的通知。
* 双向的 - 表示数据可以在两个套接字之间的任意方向上传输。
* 字节流 - 表示和管道一样不存在消息边界的概念。



### 数据报

数据报套接字（`SOCK_DGRAM`）允许数据以数据报消息的形式进行交换。

数据报的服务器过程如下： `socket()` `bind()` `recvfrom()` `sendto()` `close()` 。

数据报的的客户端过程如下： `socket()` `sendto()` `recvfrom()` `close()` 。



### 寻址

网络通信的进程标识

网络通信的进程标识由两部分组成，一部分是计算机的网络地址，它可以标识网络上我们想要通信的计算机；另一部分是该计算机上用端口号表示的服务，它可以标识特定的进程。



### 字节序

IP 地址和端口号是整数值。这些值在网络中传递时碰到的一个问题是，不同的硬件结构会以不同的顺序来存储一个多字节整数。

在处理器架构中，存储整数时，先存储“最高有效字节”的称为大端，先存储“最低有效字节”的称为小端。

注意，不管字节如何排序，“最高有效字节”（MSB） 总是在左边，“最低有效字节”（LZB）总是在右边。因此当给一个 32 位整数赋值 `0x04030201` 时，不管字节序如何，“最高有效字节”都包含 `4`，“最低有效字节”都包含 `1`。如果接下来想用一个字符指针 `cp` 强制转换到这个整数地址（`char *cp = (char *)(&n)`），就会看到字节序带来的不同。在小端字节序处理器上，`cp[0]` 指向最低有效字节因而包含 `1`，`cp[3] ` 指向最高有效字节因而包含 `4` 。在大端字节序处理器上，`cp[0]` 指向最高有效字节因而包含 `4`，`cp[3] ` 指向最低有效字节因而包含 `1` 。


```
         ×××××××××××××××××××××××××××××××××
         ×   n   | n + 1 | n + 2 | n + 3 ×  大端
         ×××××××××××××××××××××××××××××××××
         MSB                           LZB

         ×××××××××××××××××××××××××××××××××
         × n + 3 | n + 2 | n + 1 |   n   ×  小端
         ×××××××××××××××××××××××××××××××××    
         MSB                           LZB     
```



### 字节序转换

网络协议指定了字节序，因此异构计算机系统能够交换协议信息而不会被字节序混淆。TCP/IP 协议栈使用大端字节序。应用程序交换格式化数据时，字节序问题就会出现，应用程序需要在处理器的字节序和网络字节序之间转换。



### 地址查询

进行网络通信时，网络配置信息会被存储在许多地方。这些信息可以存放在静态文件 */etc/hosts* */etc/services* 中，也可以由名字服务管理，如域名系统（Domain Name System，DNS）或者网络信息服务（NIS）。无论这个信息放在何处，都可以使用同样的函数访问它。



### 数据传输

尽管可以通过 `read()` `write()` 读写套接字，但是如果想指定选项，从多个客户端接收数据包，或者发送带外数据，就需要 `recv()` `recvfrom()` `recvmsg` `send` `sendto` `sendmsg` 。



### 套接字配置

套接字机制提供了两个套接字配置接口来控制套接字行为。可以获取和设置以下 3 种选项：

* 通用选项，适用所有套接字类型
* 在套接字层次管理的选项，但是依赖下层协议的支持
* 协议特有的选项

###

## 程序和进程

### 何谓程序？

编译过的，可执行的二进制代码，保存在存储介质如磁盘上，不运行。规模很大的二进制程序集可以称为应用。



### 何谓进程？

正在运行的程序实例，执行给定的二进制代码，有自己的执行栈内存。有自己的＂页表＂，有自己的＂文件描述符表＂，有一个唯一的＂进程号码＂。



### 进程号码

每个进程都由一个唯一的标识符表示，即＂进程号码＂。使用数据类型 `pid_t` 来表示。`pid_t` 定义在 `<sys/types.h>`，与平台和硬件相关，在 Linux 中通常定义为 `int` 类型。

内核分配进程号码，是以严格的线性方式执行的。如果当前进程号码最大值是 `317`，那么分配给新进程的进程号码就是 `318`。当到达最大值后，进程计数器重置为 `300` （不是 `1`，前 `300` 一般用于系统进程和守护进程）。 

在 Linux 中，进程号码最大值为 `32768`，这是为了和老的 UNIX 系统兼容，因为这些系统使用了 `signed short int` 16 位数表示进程号码。系统管理员可以修改 */proc/sys/kernel/pid_max* 把这个值设置成更大的值，但是会牺牲一些兼容性。32 位系统中最大值可以是 `32768`，64 位系统中最大值可以是 `2^22`（约 400 万）。

### 子进程和父进程

创建新进程的进程，称为父进程，新进程称为子进程。每个进程都是由其他进程创建（除了 **init** 进程），因此每个子进程都有一个父进程。进程之间呈树状关系。

**init** 进程是根进程，进程号码是 `1`，在系统自举过程结束时由内核执行，以超级用户特权运行，是所有进程的始祖。命令 `$ pstree` 可以查看家族树，文件 */proc/${PID}/status* 可以查看进程信息。



### fork

系统调用 `fork()` 用来创建一个新的进程，基本上相当于复制其父进程。在新进程中执行一个新的程序需要 2 个步骤：首先，`fork()` 一个新的进程，然后，通过 `exec()` 把新的二进制程序加载到该进程中，替换掉原来的地址空间内容。

fork() 后子进程继承父进程的很多属性：

* 实际用户号码，实际组号码，有效用户号码，有效组号码，保留用户号码，保留组号码
* 附属组号码
* 进程组号码
* 会话号码（进程组首进程号码）
* 控制终端
* 当前工作目录
* 根目录 
* 文件模式创建屏蔽字
* 信号屏蔽和安排
* 对任一打开文件描述符的＂执行时关闭＂（close-on-exec）标识
* 环境
* 连接的共享存储段
* 存储映像
* 资源限制



### exec

系统调用 `execve()` 可以将新程序加载到进程的内存空间，进程原有的＂内存页＂记录会被替换，＂文件描述符表＂记录默认会保留（如果在打开文件时，设置了 `FD_CLOEXEC` 标志位，会关闭该文件），＂进程号码＂不变。

如果可执行文件设置了＂保留号码＂权限位，进程程序的属主（组）号码置为＂有效号码＂。利用这一机制，可使用户在运行特定程序时临时获得特权。另外，以进程原有的＂有效号码＂覆盖＂保留号码＂。其他的调用基于 `execve()`。



### 子进程终止和应答子进程

一旦创建了一个新进程，其就成为调用进程的子进程。当一个进程正常或者异常结束时，内核就向其父进程发送 SIGCHILD 信号。子进程结束是一个异步事件，可以在父进程运行的任何时候发生，所以这种信号由内核向父进程发送异步通知。父进程可以选择忽略该信号，也可以提供一个信号处理函数。

有两种可能存在的情况：父进程先于子进程退出，子进程先于父进程退出。



### 僵尸进程

当子进程退出时，并不立刻清空进程表，而是向父进程发送一个信号 `SIGCHLD`。父进程需要对此应答，然后系统会完全清除子进程。假设父进程没有应答，或者应答之前子进程退出，子进程会被系统设置为＂僵尸＂状态，释放子进程的大部分资源，在＂内核进程表＂中保留子进程的状态记录，包括子进程号码，终止状态，资源使用数据等信息。如果＂僵尸进程＂过多，会导致＂内核进程表＂塞满，无法创建新的进程。



### 孤儿进程

当一个父进程退出时，如果有几个子进程仍在运行，这些子进程会变成＂孤儿进程＂。＂孤儿进程＂会立刻被 **init** 进程接管，作为其父进程。**init** 进程能够确保这些子进程在退出时不会变为＂僵尸进程＂，因为 **init** 进程总是应答子进程的退出。

### 终止进程

有 8 种方式可以终止进程。

5 种正常终止

* 从 `main` 返回
* 调用 `exit()`
* 调用 `_exit()`，`_Exit()`
* 最后一个线程从启动例程返回
* 从最后一个线程调用 `pthread_exit()`

3 种异常终止

* 调用 `abort()`
* 接到一个信号
* 最后一个线程对取消请求作出响应



无论进程是否正常终止，都会发生如下动作

* 关闭所有打开的＂文件描述符号码＂，目录流，＂信息目录描述符号码＂，＂字符集转换描述符号码＂。
* 释放持有的任何文件锁
* 分离任何已连接的　　System　V 共享内存段
* 为每个 System V 新洪亮设置的 semadj 加到信号量值
* 如果进程是一个管理终端的管理进程，向终端前台进程组的每个进程发送 SIGHUP 信号，然后终端与会话脱离
* 关闭打开的 POSIX 有名信号量
* 关闭打开的 POSIX 消息队列
* 如果某进程组称为＂孤儿进程组＂，并且改组重存在已停止进程，组中的所有进程都将收到 **SIGHUP** 信号，随之为 **SIGCONT** 信号
* 移除通过 `mlock` `mlockall` 建立的内存锁
* 取消通过 `mmap` 建立的内存映射



### 命令行参数

`main` 函数的 `argv` 作为一个命令参数，是一个字符串数组。可以使用 `getopt()` 解析命令行选项。



### 环境变量

每一个进程有与其关联的环境列表，一个字符串数组，以＂名=值＂表示。这是早期的进程间通信方式，一次性，单向。全局变量 `environ` 包含了该字符串数组：

```
  extern char **environ;
```



### 跳转

系统调用 `setjmp()` `longjmp()` 可以跳转到当前执行函数外的位置。比如多级嵌套函数调用中，当出错时，直接跳出到某个指定的调用者，立刻完成调用。这比起层层返回错误，并且检查会更方便。   

###

## 用户和组

### 何谓用户和组？

每个进程都属于某个用户和某个组，这种从属关系用来实现访问控制。对于内核来说，用户和组不过是些整数值。通过 */etc/passwd* 和 */etc/group* 两个文件，这些整数被映射成人们易读的形式。

一个进程的＂用户号码＂和＂组号码＂代表这个进程可以执行那些操作，进程必须以合适的用户和组运行。许多进程是以 **root** 用户运行。然而，在软件开发中，最好采取＂最小权限＂原则，进程要尽可能以最小权限来运行。
>
最小权限原则是动态变化的：如果进程在前期需要以 **root** 用户的权限运行，而在后面不再需要 **root** 权限了，那么它就应该在后期尽可能地放弃　**root** 权限。



### 超级用户

超级用户在系统中享有特权，＂用户号码＂是 `0`，通常＂登录名＂是 **root**，可以访问系统中的任何文件，也能发送信号干预系统运行的所有用户进程。系统管理员可以使用超级用户账号来执行各种系统管理任务。 



### 用户号码

＂用户号码＂以 `uid_t` 类型表示，定义在 `<pwd.h>`。＂组号码＂以 `gid_t` 表示，定义在 `<grp.h>`。



### 实际用户号码和组号码

在用户登录时，登录 shell 通过 */etc/passwd* 读取用户记录，将记录的第 3 字段和第 4 字段设置为该登录用户的＂实际用户号码＂和＂实际组号码＂。这个登录用户创建的所有进程都会继承这些值。 



### 有效用户号码和组号码

＂有效用户号码＂、＂有效组号码＂、和＂附属组号码＂一起来确定进程访问资源的权限。初始时，＂有效用户号码＂和＂有效组号码＂等于＂实际用户号码＂和＂实际组号码＂。默认情况下，子进程继承父进程的＂有效用户号码＂，并且调用 `exec()` 也不会改变。通过调用 `setuid(u)`，可以改变进程的＂有效用户号码＂。＂有效用户号码＂是 `0` 的进程拥有超级用户的所有权限，这样的进程称为特权进程！



### 保留用户号码和组号码

是进程原有的＂有效用户号码＂和＂有效组号码＂的备份。当调用 `exec()` 创建子进程时，内核会把＂保留用户号码＂和＂保留组号码＂设置为＂有效用户号码＂和＂有效组号码＂，保存一份＂有效用户号码＂和＂有效组号码＂的记录。



### 附属组号码

一个用户会参与多个项目，因此需要同时属于多个组。使用＂附属组号码＂，不必显式的经常更改组。一个用户可以同时属于 <=16 个另外的组。



### 口令文件

UNIX 系统口令文件（POSIX.1 称为用户数据库），含有如下的数据字段（定义在 `<pwd.h>`）：

<table>
<tr>
  <th class="ta-c">说明</th>
  <th class="ta-c">struct passwd</th>
  <th class="ta-c">POSIX.1</th>
  <th class="ta-c">FreeBSD8.0</th>
  <th class="ta-c">Linux3.2.0</th>
  <th class="ta-c">Mac OSX 10.6.8</th>
  <th class="ta-c">Solaris10</th>
</tr>
<tr>
  <td>用户名</td>
  <td>`char *pw_name`</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td>加密口令</td>
  <td>`char *pw_passwd`</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td>用户号码</td>
  <td>`uid_t *pw_uid`</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td>组号码</td>
  <td>`gid_t *pw_gid`</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td>注释</td>
  <td>`char *pw_gecos`</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td>初始工作目录</td>
  <td>`char *pw_dir`</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td>初始 shell</td>
  <td>`char *pw_shell`</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td>用户访问类</td>
  <td>`char *pw_class`</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c"></td>
</tr>
<tr>
  <td>下次更改口令时间</td>
  <td>`time_t *pw_change`</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c"></td>
</tr>
<tr>
  <td>账户有效时间</td>
  <td>`time_t *pw_expire`</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c"></td>
</tr>
</table>

口令文件是 */etc/passwd*，一个 ASCII 文件：

```
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
sshd:x:117:65534::/var/run/sshd:/usr/sbin/nologin
king:x:1000:1000:king,,,:/home/king:/bin/bash
>
#| ⋅ 有一个超级用户 root，用户号码是 0
#| ⋅ 加密口令是一个占位符。其实际的内容，放置在特权程序才能读取的 /etc/shadow，以防止密码比对攻击
#| ⋅ 口令文件中某些字段可以是空值
#| ⋅ shell 字段是一个可执行程序名，用做用户的登录 shell，如果为空，取默认值 "/bin/sh"
#| ⋅ shell 字段设为 "/dev/null" 或者 ＂/bin/false＂，可以阻止该用户通过 shell 登录到系统
#| ⋅ 使用 nobody 用户名，可以使任何人登录到系统。其用户号码和组号码不提供任何特权，只能访问人人
#|   皆可读写的文件
```



### 阴影口令文件

阴影口令文件，包含了实际的加密内容，含有如下字段（定义在 `<shadow.h>`）：

<table>
<tr>
  <th class="ta-c">说明</th>
  <th class="ta-c">struct spwd</th>
</tr>
<tr>
  <td>用户名</td>
  <td>`char *sp_namp`</td>
</tr>
<tr>
  <td>加密口令</td>
  <td>`char *sp_pwdp`</td>
</tr>
<tr>
  <td>上次更改口令后，经过的时间</td>
  <td>`long *sp_lstchg`</td>
</tr>
<tr>
  <td>经多少天后允许更改</td>
  <td>`long *sp_min`</td>
</tr>
<tr>
  <td>要求更改尚余天数</td>
  <td>`long *sp_max`</td>
</tr>
<tr>
  <td>超期警告天数</td>
  <td>`long *sp_warn`</td>
</tr>
<tr>
  <td>账户不活动之前尚余天数</td>
  <td>`long *sp_inact`</td>
</tr>
<tr>
  <td>账户超期天数</td>
  <td>`int *sp_expire`</td>
</tr>
<tr>
  <td>保留</td>
  <td>`unsigned int *sp_flag`</td>
</tr>
</table>

阴影口令文件是 */etc/shadow*，只有特权用户才能访问，仅有少数几个程序需要访问加密口令，如 `login`，`passwd`。



### 组文件

UNIX 组文件（POSIX.1 称为组数据库）含有如下字段（定义在 `<grp.h>`）：

<table>
<tr>
  <th class="ta-c">说明</th>
  <th class="ta-c">struct group</th>
  <th class="ta-c">POSIX.1</th>
  <th class="ta-c">FreeBSD8.0</th>
  <th class="ta-c">Linux3.2.0</th>
  <th class="ta-c">Mac OSX 10.6.8</th>
  <th class="ta-c">Solaris10</th>
</tr>
<tr>
  <td>组名</td>
  <td>`char *gr_name`</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td>加密口令</td>
  <td>`char *gr_passwd`</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td>组号码</td>
  <td>`gid_t *gr_gid`</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td>用户名列表</td>
  <td>`char **gr_mem`</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
</table>

组文件是 */etc/group*，每行 4 个字段：

```
root:x:0:
daemon:x:1:
adm:x:4:syslog,king
```
>
假如用户 avr 是 users，staff，teach 组的成员，从 */etc/passwd* 可以看到如下记录：
>
```
avr:x:1001:100:Anthony Robins:/home/avr:/bin/bash
```

从 */etc/group* 可以看到如下记录：

```
users:x:100:
staff:x:101:mtk,avr,martinl
teach:104:avr:rlb,alc
```



### 组阴影口令文件

组阴影口令文件是 */etc/gshadow*。



### 更多数据文件

日常操作中，UNIX 系统会使用很多数据文件。比如，BSD 有一个记录各服务器提供服务的数据文件 */etc/services*，有一个记录协议信息的数据文件 */etc/protocols*，还有一个则是纪录网络信息的数据文件 */etc/networks*。这些数据文件的接口，都与口令文件和组文件的相似。

一般情况下，对每个数据文件至少有 3 个函数：

* get 函数：读下一个记录，如果需要，还会打开该文件。通常返回一个静态存储的记录结构指针，如果要保存其内容，需要复制它。当到达文件尾短时返回空指针
* set 函数：打开数据文件（如果尚未打开），返回文件起始处
* end 函数：关闭数据文件

有些数据文件，还提供某种形式的键搜索，例子：

<table>
<tr>
  <th class="ta-c">说明</th>
  <th class="ta-c">数据文件</th>
  <th class="ta-c">头文件</th>
  <th class="ta-c">结构</th>
  <th class="ta-c">附加的键搜索函数</th>
</tr>
<tr>
  <td>口令</td>
  <td>*/etc/passwd*</td>
  <td>`<pwd.h>`</td>
  <td>`passwd`</td>
  <td>`getpwnam()` `getpwuid()`</td>
</tr>
<tr>
  <td>组</td>
  <td>*/etc/group*</td>
  <td>`<grp.h>`</td>
  <td>`group`</td>
  <td>`getgrnam()` `getgrgid()`</td>
</tr>
<tr>
  <td>阴影</td>
  <td>*/etc/shadow*</td>
  <td>`<shadow.h>`</td>
  <td>`spwd`</td>
  <td>`getspnam()`</td>
</tr>
<tr>
  <td>主机</td>
  <td>*/etc/hosts*</td>
  <td>`<netdb.h>`</td>
  <td>`hostent`</td>
  <td>`getnameinfo()` `getaddrinfo()`</td>
</tr>
<tr>
  <td>网络</td>
  <td>*/etc/networks*</td>
  <td>`<netdb.h>`</td>
  <td>`netent`</td>
  <td>`getnetbyname()` `getnetbyaddr()`</td>
</tr>
<tr>
  <td>协议</td>
  <td>*/etc/protocols*</td>
  <td>`<netdb.h>`</td>
  <td>`protoent`</td>
  <td>`getprotobyname()` `getprotobynumber()`</td>
</tr>
<tr>
  <td>服务</td>
  <td>*/etc/services*</td>
  <td>`<netdb.h>`</td>
  <td>`servent`</td>
  <td>`getservbyname()` `getservbyport()`</td>
</tr>
</table>



### 用户登录记录

UNIX 系统，使用 **utmp** 文件用于记录登录到系统的各个用户，**wtmp** 文件跟踪各个登录和注销事件。登录时，`login` 程序填写 **utmp** 文件，同时填写 **wtmp** 文件。注销时，**init** 进程将 **utmp** 对应的记录擦除（每个字节填以 null 字节），并将一个新纪录填写到 **wtmp** 文件。在 **wtmp** 文件的注销记录， `ut_name` 字段清除为 0。当系统在此启动时，以及更改系统时间和日期前后，都在 **wtmp** 文件追加写特殊的纪录项。`who` 程序读取 **utmp** 文件，并以可读格式打印。

###

## 进程组、会话和作业控制

### 进程组

每个进程都属于某个进程组。进程组是由一个或者多个为了实现作业控制而相互关联的进程。进程们接收来自同一个终端的信号。信号可以发送给进程组中所有进程：单个操作可以使同一个进程组中的所有进程终止、停止或者继续运行。

子进程通常属于父进程所在的进程组（通过继承）。此外，当通过 **shell** 建立管道时，比如 `$ ls | less`，所有和管道相关的命令都是同一个进程组。进程组使得在管道上的进程之间发送信号或者获取信息变得很容易，同样，也适用于管道中的子进程。从用户角度来看，进程组合作业是紧密关联的。

＂进程组号码＂同＂进程号码＂一样，使用 `pid_t` 表示。进程只能设置自己或者自己的子进程的＂进程组号码＂。在子进程调用了 `exec()` 后，就不能再更改该子进程的＂进程组号码＂。



### 进程组首进程

每个进程组有一个＂进程组首进程＂。＂进程组号码＂就是＂进程组首进程号码＂。只要进程组中有一个进程存在，进程组就存在，即使＂进程组首进程＂已经终止。进程组中的进程可以终止，也可以移到另一个进程组。



### 会话

当有新的用户登录计算时，登录进程就为这个用户创建一个新的会话。这个新的会话只包含单个进程：用户的登录　shell 。登录　shell 作为＂会话首进程＂，其＂进程号码＂作为＂会话首进程号码＂。会话是一个或者多个进程组的集合，囊括了登录用户的所有活动，并且分配给用户一个控制终端（用于处理用户 IO 的特定 tty 设备）。因此，会话的功能和 shell 差不多。实际上，没有刻意去区分它们。

在指定的系统中，存在着多个会话，每个用户的登录都是一个会话，还有一些是与用户登录会话无关进程（例如守护进程）。每个会话包含一个或多个进程组，每个进程组包含一个或多个进程。多进程的进程组通常是用来完成作业控制。



```
 ***************************************************************************************
 *                                                                                     *   
 * ###################   #############################   ############################# *
 * # +-------------+ #   # +----------+ +----------+ #   # +----------+ +----------+ # *
 * # | login shell | #   # | process1 | | process2 | #   # | process3 | | process4 | # *
 * # +-------------+ #   # +----------+ +----------+ #   # +----------+ +----------+ # *
 * ###################   #############################   #       +----------+        # *
 *       进程组                       进程组               #       | process5 |        # *
 *                                                       #       +----------+        # *
 *                                                       ############################# *    
 *                                                                   进程组             * 
 ***************************************************************************************     
                                       会话                                                              
```

<span>

```

                 fork()                 fork()            exec()
        sh(949) -------sh(1988) -----------sh(1989) -------ps(1989)
          ＾               |                                     .
            .              |                                     . 管道
              .            |           fork()            exec()  v
                .          | exec()   -------sh(1990) -------cat(1990)
 终止时通知父进程    .       |                                      .
                    .      |   ....................................
                      .    v   v               管道
                        .cat(1988)


```



### 前端进程组和后台进程组

会话把进程组分为一个前端进程组和零个或者多个后台进程组。当用户退出终端时，会向前端进程组中的所有进程发送 `SIGQUIT` 信号。当终端发现网络中断时，会向前端进程组中的所有进程发送 `SIGHUP` 信号。当用户敲入了终止键（一般是 Ctrl+C），会想前端进程组中的所有进程发送 `SIGINT` 信号。因此，会话使得 shell 可以更容易管理终端以及登录行为。



### 作业控制

在指定的系统中，存在着多个会话，每个用户的登录都是一个会话，还有一些是与用户登录会话无关进程（例如守护进程）。每个会话包含一个或多个进程组，每个进程组包含一个或多个进程。多进程的进程组通常是用来完成作业控制。


```
  $ cat foo.txt | grep booty | sort
```

这条 **shell** 命令产生 3 个进程构成的进程组，**shell** 可以向 3 个进程同时发送信号。结尾没有使用 & ，所以是一个前端进程组。

启动两个作业：

```
$ make all Make.out &
[1]    1475                           // 作业 1，进程号码 1475
$ pr *.c | lpr & 
[2]    1490                           // 作业 2，进程号码 1490
$   
[2] + Done    pr *.c | lpr &
[1] + DOne    make all Make.out &
```



### 后台作业读终端

我们可以有一个前台作业，多个后台作业，只有前台作业能接收终端输入。如果后台作业，试图读终端，终端驱动程序会对此检测，并且向后台作业发送一个特定信号 `SIGTTIN`，该通常会停止此后台作业，shell 则向用户发出该情况的通知。用户可以用 shell 命令，将此作业从后台转为前台，就可以读终端：

      $ cat temp.md &                       // 在后台启动，但将从标准输入读
      [1]    1681
      $                                       // 输入回车
                                              // 试图读终端（标准输入），终端驱动程序直到它是个
                                              // 后台作业，发送 `SIGTTIN` 信号，停止作业
      [1] + Stopped(SIGTTIN) cat temp.md &  // shell 检测到子进程的状态变化，通知作业已停止
      $ fg %1                                 // 使 1 号作业转为前台。`bg` 转为后台
      cat temp.md                           // 通知用户，现在哪一个作业在前台
      Hello world!                            // 输入一行
      ^D                                      // 输入文件结束符
      $ cat temp.md                           // 显示文件内容
      Hello world!



### 后台作业写终端

可以使用 `stty` 禁止后台作业输出到终端：

      $ cat temp.md &                         // 在后台执行
      [1]    1719
      $ Hello, world!                         // 输入回车
      [1] + Done         cat temp.md & 
      $ stty tostop                           // 禁止后台作业输出到终端 
      $ cat temp.md &                         // 再试一次
      [1]    1721
      $                                       // 输入回车，发现作业已停止
      [1] + Stopped(SIGTTOU)               
      $ fg %1                                 // 使 1 号作业转为前台
      cat temp.md                             // 通知用户，现在哪一个作业在前台
      Hello, world!                           // 作业输出



### 守护进程

守护进程运行在后台，不与任何控制终端关联。通常在系统启动时就运行，以 root 用户或者其他特殊用户（例如 mysql 和 postfix）运行，并处理一些系统级的任务。习惯上守护进程的名字通常以 d 结尾（例如 sshd mysqld）。

对于守护进程，有两个基本要求

* 必须作为 **init** 进程的子进程运行
* 不与任何控制终端交互



通常，进程可以通过如下步骤成为守护进程

1. 调用 `fork()`，创建子进程，该进程将会成为守护进程
2. 在父进程中调用 `exit()`，使 **init** 进程成为守护进程的父进程
3. 调用 `setsid()`，创建一个新会话，使守护进程成为＂会话首进程＂，同时确保没有控制终端相关联
4. 调用 `chdir()`，更改程序的＂工作目录＂
5. 关闭所有打开的＂文件描述符号码＂
6. 打开＂文件描述符号码＂ `0` `1` `2`，并重定向到 */dev/null*

###

## 终端登录

在早期的 UNIX 系统，用户用哑终端（硬连接接到主机）进行登录。随着位映射图形终端的出现，开发出了窗口系统，仿真基于字符的终端，使用户可以用熟悉的方式（shell）与主机进行交互。



### BSD

      #|           *---------*
      #|           |  init   |
      #|           *---------*
      #|           /    |          #|   fork() v     |     v fork()
      #|                v fork()
      #|           *---------*
      #|           |  init   |
      #|           *---------*
      #|                |
      #|                v exec()
      #|           *---------*
      #|           |  getty  |
      #|           *---------*  open() 0，1，2 初始化环境集
      #|                |
      #|                v exec()
      #|           *---------*
      #|           |  login  |
      #|           *---------*  
      #|                |
      #|                v exec()
      #|           *---------*
      #|           |  shell  |
      #|           *---------*
      #|                ^ 
      #|                |  fd 0，1，2
      #|                v
      #|         ＜ 终端设备驱动 ＞
      #|                ^
      #|                |         （硬连接）
      #|                v
      #|             ＂用户＂

  1. 当系统自举时，内核创建 **init** 进程。

  2. **init** 进程使系统进入多用户模式，读取 */etc/ttys*，对每一个（允许）登录的终端设备调用 `fork()`，新的进程 `exec(getty)` 程序。

  3. **getty** 对终端设备调用 `open()`，以读写方式打开终端，＂文件描述符号码＂ `0`，`1`，`2` 设置到该设备，然后 **getty** 输出 ＂login: ＂，等待用户输入用户名。当登录者输入用户名后，**getty** 完成工作，`exec(login)` 程序。

  4. **login** 随后调用 `getpwnam()` 取得用户的口令文件记录，调用 `getpass()` 显示 ＂Password: ＂，接着读取用户输入的口令，调用 `crypt()` 将口令加密，与用户在阴影口令文件的 `pw_passwd` 比较。如果用户输入几次的口令都无效，则 **login** 调用 `exit(1)` 退出进程（登录失败）。

  5. **init** 进程（父进程），了解到子进程终止后，再次调用 `fork()`，其后又执行 **getty**，重复上述过程。

  6. 如果用户登录正确，**login** 将完成如下工作：

     * 调用 `chdir()` 更改＂当前工作目录＂为用户的起始目录
     * 调用 `chown()` 更改＂该终端的属主＂为登录用户
     * 调用 `chmod()` 更改＂对该终端的访问权限＂为＂用户读和写＂
     * 调用 `setgid()` `initgroups()` 更改＂进程组号码＂
     * 使用 **login** 得到的信息初始化环境：起始目录（HOME），shell（SHELL），用户名（USER 和 LOGNAME），系统默认路径（PATH）
     * 调用 `setuid()` 更改 3 个用户号码为＂登录用户的用户号码＂，并调用该用户的登录 shell

  7. 用户的登录 shell 开始运行，其父进程是 **init** 进程，＂文件描述符号码＂ `0`，`1`，`2` 设置到终端设备。

图中：

  * **init** 进程拥有超级用户特权，派生的所有进程也都有超级用户特权
  * 所有进程的＂实际用户号码＂和＂有效用户号码＂都是 `0`
  * 当 `exec()` 时，＂进程号码＂不改变
  * 除了 **init** 进程，所有进程的＂父进程号码＂是 `1`

这是 UNIX 系统传统的用户身份验证过程。现在 UNIX 系统可以支持多个身份验证过程。例如，FreeBSD，Linux，Mac OS X，Solaris 都支持称为 PAM 的更加灵活的方案。



### Mac OS X

部分的基于 FreeBSD，**init** 的工作由 **launchd** 完成。



### Linux

类似 FreeBSD。一些发行版本采用了＂Upstart＂的 **init** 程序，使用存放在 */etc/init/* 中的 ***.conf** 配置文件。



### Solaris

* getty
* ttymon   

###

## 网络登录

网络登录时，终端和计算机之间的连接，不是点到点的。**login** 此时仅仅是一种可选用的服务。所有登录，实际都经由内核的网络接口驱动程序，并且事先不知道有多少登录。因此，必须等待一个＂网络连接请求＂的到达，而不是使一个进程等待＂每一个可能的登录＂。

为使同一个软件，既能处理终端登录，又能处理网络登录，UNIX 系统使用＂伪终端＂的软件驱动程序，仿真串行终端的行为，并将终端操作和网络操作互相映射。



### BSD

      ##           *---------*
      ##           |  init   |
      ##           *---------*
      ##                .  
      ##                .  系统出现多用户时，/bin/sh 中的 fork/exec 执行 /etc/rc    
      ##                v 
      ##           *---------*    TELNET 客户进程
      ##           |  inetd  |  <---------------- $ telnet hostname 
      ##           *---------*    TCP/IP 连接请求
      ##                |
      ##                v fork()
      ##           *---------*
      ##           |  inetd  |
      ##           *---------* 
      ##                |
      ##                v exec()
      ##           *---------*
      ##           | telnetd |
      ##           *---------*  
      ##                .
      ##                .  login ...
      ##                v
      ##           *---------*
      ##           |  shell  |
      ##           *---------*
      ##                ^ 
      ##                |  fd 0，1，2
      ##                v
      ##         ＜ 伪终端设备驱动 ＞
      ##                ^
      ##                .         （网络连接）
      ##                v
      ##             ＂用户＂

  1. **init** 进程调用一个 shell，执行脚本 */etc/rc*，启动一个守护进程 **inetd**（一旦此 shell 脚本终止，   　 **inetd** 的父进程就变成 **init** 进程）

  2. **inetd** 进程等待 TCP/IP 连接请求。当一个连接请求到达时，调用 `fork()`，`exec()` 适当的程序（比如 telnet，sshd，sftpd）
 
  3. **telnetd** 进程打开一个伪终端，调用 `fork()` 。父进程处理网络连接的通信，子进程执行 **login** 程序。父子进程通过伪终端连接

  4. 当正确登录后，启动用户登录 shell



### Mac OS X

部分的基于 FreeBSD。



### Linux
  
大部分同 FreeBSD。



### Solaris

 大部分同 FreeBSD。

 ###

## 线程

### 何谓线程？

线程是是指单个进程内，多路并行执行的创建和管理单元。

一个进程包含一个或多个线程。如果一个进程只包含一个线程，则该进程只有一个执行单元，每次只有一个操作在执行。我们称这种进程为＂单线程＂。如果一个进程包含多个线程，每次会有多个操作在同时执行。我们称这种进程为＂多线程＂。



### 虚拟内存和虚拟处理器

现代操作系统包括了两种对用户空间的基础虚拟抽象：虚拟内存和虚拟处理器。

它们使得进程＂感觉＂自己独占机器资源。虚拟内存为每个进程提供独立的内存地址空间，该内存地址连续映射到物理内存 RAM 或者 磁盘存储（swap）。实际上，系统的 RAM 中可能有 100 个不同的正在运行的进程，但是每个进程都＂感觉＂所有的内存都是自己独占的。虚拟处理器使得进程＂感觉＂只有自己正在运行，操作系统对其＂隐藏＂了事实：多个进程在多个处理器（可能）以多任务方式同时运行。

虚拟内存是和进程相关的，和线程无关。因此，每个进程有独立的内存空间，而进程中的所有线程共享这份空间。相反地，虚拟处理器是和线程相关的，与进程无关。每个线程都是可独立调度的实体，支持单个进程每次＂处理＂多个操作。和进程一样，线程也＂感觉＂自己独占一个处理器。但是，和进程不同的是，线程并没有＂感觉＂自己独占内存---进程中的所有线程共享全部内存地址空间。



### 多线程的好处

* 编程抽象 - 把工作分为多个模块，并为每个分块分配一个执行单元（线程）是解决很多问题的常见方式。利用这种方法的设计模式包括＂每个连接一个线程＂和线程池模式。

* 并发性 - 对于有多个处理器的计算机，线程提供了一种实现＂真正并发＂的高效方式。每个线程有自己的虚拟处理器，是作为独立的调度实体，因此在多个处理器上可以同时运行多个线程，从而提高系统的吞吐量。

* 提高相应能力 - 即使是在单处理器的计算机上，多线程也可以提高进程的响应能力。在单线程的进程中，一个长时间运行的任务会影响应用对用户输入的响应，导致应用看起来＂僵死＂了。有了多线程机制，这些操作可以委托给 worker 线程，至少有一个线程可以响应用户输入并执行 UI 操作。

* IO 阻塞 - 这和前一项＂提高相应能力＂紧密相关。如果没有线程，IO 阻塞会影响整个进程。在多线程的进程中，单个线程可能会因 IO 等待而阻塞，而其他线程可以继续执行。除了线程之外，异步 IO 和非阻塞 IO 也是这种问题的解决方案。

* 上下文切换 - 在同一个进程中，从一个线程切换到另一个线程的代价要显著地低于进程间的上下文切换。

* 内存保存 - 线程提供了一种可以共享内存，并同时利用多个执行单元的高效方式。从这个角度看，多线程在某些场景下可以取代多进程。



### 多线程的问题

虽然多线程有很多优势，但也不是毫无代价。事实上，有些最可怕的 bug 就是由多线程引起的。设计、编写、理解，以及最重要的---调试多线程程序，这些复杂度都远远高于单个线程的进程。

对线程恐惧的原因还在于：多个虚拟的处理器，但是只有一个虚拟内存。换句话说，多线程的进程有多个事件在同时运行（并发性），而这些事件共享同一块内存。自然而然地，同一个进程的线程会共享资源---也就是说，需要读或者写同一份数据。因此，理解程序如何工作就从理解简单的序列化执行指令转变成对多线程独立运行的理解，时间和顺序不可预测，单结果肯定是正确的。如果线程同步失败，会造成输出脏数据、运行出错以及程序崩溃。



### 其他并发选择

除了多线程外，还有一些其他选择，这取决于使用多线程的目的。比如，多线程带来的低延迟和高 IO 吞吐也可以通过 IO 多路复用、非阻塞 IO、异步 IO 来实现。这些技术支持进程并发执行 IO 操作，不会阻塞进程。如果目的是实现并发，和 N 个线程相比，N 个进程也可以同样利用处理器资源，除了增加了资源消耗代价和上下文切换开销。相反，如果目的是减少内存使用，Linux 提供了一些工具，比起多线程，它们可以以更严格的方式共享内存。

### 

## 线程模型

在一个系统上实现线程模型的方式有好几种，因内核和用户空间提供的支持而有一定程度的级别差异。



### 1:1线程模型

最简单的模型是在内核为线程提供了本地支持的情况，每个内核线程直接转换成用户空间的线程。这种模型称为＂1:1线程模型＂，因为内核提供的县城和用户的线程的数量是 1:1。该线程模型也称为＂内核级线程模型＂，因为内核是系统线程模型的核心。

Linux 中的线程就是＂1:1线程模型＂。在 Linux 内核中只是简单的将线程实现成能够共享资源的进程。线程库通过系统调用 `clone()` 创建一个新的线程，返回的＂进程＂直接作为用户空间的线程。也就是说，在 Linux 上，用户调用线程和内核调用线程基本一致。



### N:1线程模型

和＂内核级线程模型＂相反，＂用户级线程模型＂是 ＂N:1线程模型＂。在＂用户级线程模型＂中，用户空间是系统线程支持的关键，因为它实现了线程的概念。一个保护 N 个线程的进程只会映射到一个内核进程---即 N:1 。该模型很少甚至不包含内核支持，但用户空间代码有很多，包括用来管理线程的用户空间调度器，以及以非阻塞模式捕捉和处理 IO 的机制。用户线程模型的优点在于上下文切换几乎是零成本的，因为应用本身可以决定何时运行哪个线程，不需要内核操作。其缺点在于由于支持线程的内核实体只有一个，该模型无法利用多处理器，因此无法提供真正的并行性。在现代的操作系统中，这个缺点很严重。尤其是在 Linux 上，减少上下文切换代价带来的好处微乎其微，因为 Linux 支持非常低成本的上下文切换。

在 Linux 上，虽然也存在用户级线程库，大多数库提供的都是＂1:1线程模型＂。



### 协同程序和纤程

协同程序 coroutines 和纤程 fibers 提供了比线程更轻量级的执行单位（coroutines 和 fibers 的区别在于前者是编程语言中的概念，后者是系统中的概念）。和＂用户级线程模型＂类似，协同程序也属于用户空间的范畴，但是和＂用户级线程模型＂不同的是，几乎不存在用户空间对协同程序的调度和执行的支持。相反，它们是协作式调度，支持显示放弃一个程序而去执行另一个。协同程序和子程序的差别非常微小。协同程序更侧重于程序流的控制，而不是并发性。

Linux 本身并不支持协同程序，可能还是因为其上下文切换已经非常快，不需要比内核线程性能更好的结构。   

###



## 线程模式

创建多线程应用的第一步也是最重要的一步就是确定线程模式，线程模式也是应用程序的逻辑处理和 IO 的模式，可能存在很多抽象和实现细节，但两个核心的编程模式是：＂每个连接对应一个线程＂和＂事件驱动＂。



### 每个连接对应一个线程

＂每个连接对应一个线程＂是一种编程模式，在该模式中，每个工作单元被分配给一个线程，而该线程在该工作单元执行期间，不会被分配其他工作单元。工作单元是指如果分解应用的工作：请求、连接等。

描述该模式的另一种方式是＂运行直到结束＂。一个线程处理一个连接或请求，直到处理结束，这样线程就可以处理另一个新的请求。这对于 IO 很有意义，实际上，IO 是＂每个连接对应一个线程＂模式和事件驱动模式之间的一个很大区别。在＂每个连接对应一个线程＂模式种，采用阻塞式 IO---实际上任何 IO 都是允许的，因为连接＂持有＂该线程。阻塞线程只会中止引起阻塞的连接。在这种情况下，＂每个连接对应一个线程＂模式使用内核处理工作调度以及 IO 管理。

在这种模式下，线程数是个实现细节。对于大多数应用在实现时都倾向于对创建线程数设置上限。如果当前正在运行的连接数（即线程数）达到上限，新的连接可能会入队列，可能会被拒绝，直到正在执行的连接数下降到上限制以下。

注意，该模式本身并不需要线程。实际上，如果把＂线程＂替换成＂进程＂，就相当于描述老的 UNIX 服务器。比如，Apache 的标准 fork 模式就遵循这个模式。



### 事件驱动

＂事件驱动＂的线程模式和＂每个连接对应一个线程＂的模式是对立的。系统设计人员发现很多线程执行很多等待操作：读文件、等待数据库返回结果、发送远程过程调用。

在＂每个连接对应一个线程＂模式中大部分工作负荷是在等待，我们把这些等待操作从线程中抽离出来。转而通过发送异步 IO 请求和使用 IO 多路复用来管理服务器中的控制流。在这种模式中，请求处理转换成一系列异步 IO 请求及其关联的回调函数。这些回调函数可能会通过 IO 多路复用方式来等待，完成该操作的进程称为＂事件循环＂。当返回 IO 请求时，事件循环会向等待的线程发送回调。

和＂每个连接对应一个线程＂模式一样，＂事件驱动＂模式本身也不需要线程。实际上，如果一个单线程的进程执行回调时，事件循环可以完全没有。只有当真正可以提供并发时，才使用线程。在这个模式中，线程数没有理由要大于处理器数。

###

## 并发性、并行性和竞争

### 何谓并发和并行？

并发是指两个或者多个线程可以在重叠的时间周期内执行。

并行是指可以同时运行两个或者两个以上的线程。

并发不一定是并行：比如在单处理器系统上的多任务机制。并行是一种特殊的并发，它需要多个处理器（或者支持多个执行引擎的单处理器，如 GPU）。



### 竞争

由于支持重叠执行，线程以不可预测的顺序执行。当线程间需要共享资源时，将会造成＂竞争＂。程序由于不确定哪个线程先执行而带来行为不一致。

一般而言，竞争条件是指由两个或者多个线程对共享资源的非同步访问而导致错误的程序行为。共享资源可以是以下任意一种：系统硬件、内核资源或者内存中的数据。后者是最常见的，称为数据竞争。竞争所发生的窗口---需要同步的代码区，称为＂临界区＂。竞争可以通过对临界区的同步线程访问来消除。



## 同步

### 竞争窗口

竞争的最根本的源头在于临界区是个窗口，在这个窗口内，正确的程序行为要求线程不要交叉执行。为了阻止竞争条件，程序员需要在这个窗口内执行同步访问操作，确保对临界区以互斥的方式访问。



### 原子

在计算机科学中，如果一个操作（或一组操作）不可分割，我们就称其为是原子性的（atomic），不能和其它操作交叉。



### 互斥

实现临界区原子性访问的技术有很多种：从单一指令解决方案到大块的代码段。最常见的技术是锁，锁机制可以保证临界区的互斥，使得对临界区的操作具备原子性，在 Pthreads 中称之为＂互斥＂（mutexes）。

计算机中的＂锁＂和现实世界的锁的工作机制类似。假设房间是个临界区，如果没有锁，人们（线程）就可以在房间里（临界区）随意来来去去。在特定情况下，同一时刻房间里可以有多个人。因此，我们给房间安上门并锁上门。我们给这扇门发个钥匙。当有人（线程）来到门前时，他们发现钥匙在外面，就拿钥匙开门，进到房间里，然后从里面锁上门。不会再有其他人进来。他们可以在房间内做自己的事情，而不会被打扰。没有其他人会同时占用该房间，它是个互斥的资源。当这个人不需要房间时，打开门出去，把钥匙留在外面。可能会有下一个人进来，并锁上门，这样不断重复。

锁在线程机制下的工作方式很类似。程序员定义锁，并确保在进入临界区之前获取该锁，锁的实现机制确保一次只能持有一个锁。如果有另一个线程使用锁，新的线程在继续之前必须等待。如果不再在临界区，就释放锁，让等待线程（如果有的话）持有锁并继续执行。


```
  lock();
  const int money = account->money;
  account->money = money - amount;
  unlock();
```



### 锁住数据，而不是代码

好的程序员不会把代码作为锁对象。你永远不会说＂通过锁保护这个函数＂。相反，好的程序员会把数据和锁关联起来。共享数据持有关联锁，访问这部分数据需要持有关连的锁。



### 死锁

死锁是指两个线程都在等待另一个线程结束，因此两个线程都不能结束。在互斥场景下，两个线程都在等待对方持有的互斥对象。另一个场景是当某个线程被阻塞了，等待自己已经持有的互斥对象。

避免死锁很重要，要向持续、安全地做到这一点，唯有从一开始的设计中就为多线程程序设计好锁的机制。互斥体应该和数据关联，而不是和代码关联，从而有清晰的数据层。比如，一种简单的死锁方式是 ＂ABBA 死锁＂。当一个线程先获取互斥锁 A，然后获取互斥锁 B，而另一个线程先获取互斥锁 B，然后是 A（即 ABBA），就会发生这种情况。这两个线程都可以成功获取第一个互斥锁：线程 1 持有 A，线程 2 持有 B。当它们要获取另一个互斥时，发现被另一个线程持有，因此这两个线程都阻塞在那里。因为每个持有互斥的线程都在等待另一个互斥，双方都没有释放自己持有的互斥，因而导致线程死锁。

解决这个问题需要有明确的原则：必须总是先获取互斥 A，然后获取互斥 B。由于程序的复杂性和同步机制变得更加复杂，越到后来加强这些原则只会变得更加困难。早点开始，设计简洁。

###

## Pthreads

### Pthreads

Linux 内核只为线程的支持提供了底层原语，比如 `clone()` 系统调用。多线程库在用户空间。很多大型软件项目制定只自己的线程库：Android、Apache、GNOME 和 Mozilla 都提供自己的线程库。然而 POSIX.1c 对多线程库进行了标准化。开发人员称之为 POSIX 线程，或简称为 Pthreads 。Pthreads 是 UNIX 系统上 C 和 C++ 语言的主要线程解决方案。

在 Linux 中，Pthreads 标准的实现是通过 glibc 提供的，即 Linux 的 C 库。随着时间推移，glibc 提供了两个不同的 Pthreads 实现机制：LinuxThreads 和 NPTL 。使用命令 `$ getconf GNU_LIBPTHREAD_VERSION` 可以查看系统提供的线程实现。



### LinuxThreads

LinuxThreads 是 Linux 原始的 Pthread 实现，提供 1:1 的线程机制。它的第一版被包含在 glibc 的 2.0 版本中，虽然只是作为外部库提供。LinuxThreads 在设计上是为了内核设计的，它提供非常少的线程支持：和创建一个新的线程的 `clone()` 系统调用不同。LinuxThreads 通过已有的 UNIX 接口实现了 POSIX 线程机制。



### NPTL

本地 POSIX 线程库 （NPTL） 比 LinuxThreads 要优越，在 Linux 2.6 和 glibc 2.3 引入。NPTL 也是基于 `clone()` 系统调用和内核模型提供了 1:1 线程模式。除此之外，突出了内核 2.6 新增的额外内核接口，包括用于线程同步的 `futex()` 系统调用，以及 `exit_group()` 系统调用，用于终止进程中的所有线程，内核支持线程本地存储（TLS）模式。NPTL 解决了 LinuxThreads 的非一致性问题，极大提升了线程的兼容性，支持在单个进程中创建几千个线程，而且不回变慢。

虽然基于 LinuxThreads 的系统开始成长起来，而且现在还有。但是 NPTL 是 LinuxThreads 的一个很大改进，强烈建议把系统更新到 NPTL （抛弃一个很古老的系统其实不需要理由），如果没有更新到 NPTL 的话，那就还是采用单线程编程吧。



### 链接 Pthreads

虽然 Pthreads 是由 glibc 提供的，但它在独立库 libpthread 中，因此需要显示链接。有了 **gcc**，可以通过 **-pthread** 标志位来自动完成，它确保链接到可执行文件的是正确的库：

```
    $ gcc -Wall -Werror -pthread test.c -o test
```



### 线程数据类型

Pthreads 定义了一干数据类型，如下表。SUSv3 并未规定如何实现这些数据类型，可移植的程序应该将其视为＂不透明＂数据。亦即，程序应避免对此类数据类型变量的结果或者内容产生任何依赖。尤其是，不能使用 C 语言的比较操作符 `==` 去比较这些类型的变量。


数据类型|描述
-------|----
pthread_t|线程号码
pthread_attr_t|线程属性
pthread_mutex_t|互斥量
pthread_mutexattr_t|互斥量属性
pthread_rwlock_t|读写锁
pthread_rwlockattr_t|读写锁属性
pthread_cond_t|条件变量
pthread_condattr_t|条件变量属性
pthread_barrier_t|屏障
pthread_barrierattr_t|屏障属性
pthread_key_t|线程特有数据的键
pthread_once_t|一次性初始化控制上下文



### errno

传统 UNIX API 中，`errno` 是一个全局整数值。然而，这无法满足多线程程序的需要。如果线程函数是通过全局`errno` 返回错误，那么多个线程在检查 `errno` 时就会发生混乱。换句话说，这将引发对 `errno` 修改的竞争。

因此，在多线程程序中，每个线程都有属于自己的 `errno` 。在 Linux 中，线程特有的 `errno` 的实现方式与大多数 UNIX 实现类似：将 `errno` 定义为一个宏，可以以 `errno=value` 的方式对 `errno` 赋值，为每个线程所独有。

`errno` 机制在保留传统 UNIX API 报错的同时，也适应了多线程环境。最初的 POSIX.1 标准沿袭 K & R 的 C 语言用法，允许程序将 `errno` 声明为 `extern int errno` 。SUSv3 却不允许这一做法（这一变化实际发生于 1995 年的 POSIX.1c 标准）。如今，需要声明 `errno` 的程序必须包含 `<errno.h>`，以启用对 `errno` 的线程级实现。 



### 返回值

传统的从系统调用和库函数返回状态的做法是：返回 `0` 表示成功，返回 `-1` 表示出错，并设置 `errno` 以标识错误原因。Pthreads 则反其道而行之。所有 Pthreads 函数均以返回 `0` 表示成功，返回一个`错误编号`表示出错。



### 线程栈

创建线程时，每个线程都有一个属于自己的线程栈，且大小固定。在 Linux/x86-32 架构上，除主线程外的所有线程，其栈的默认大小均为 `2MB` 。（在一些 64 位架构下，默认尺寸要大一些，比如  IA-64 有 `32MB`）。为了应对栈的增长，主线程栈的空间要大出许多。

偶尔也需要改变线程栈的大小。创建线程时，通过调用 `pthread_attr_setstacksize()` 可以同时控制线程栈的大小和位置，不过设置栈的地址会降低程序的可移植性。

更大的线程栈可以容纳大型的自动变量或者深嵌套的函数调用（也许是递归调用）。另一方面，应用程序可能希望减小每个线程栈，以便进程可以创建更多的线程。比如在 x86-32 系统中，用户（模式）可访问的虚拟地址空间是 `3GB`，而 `2MB` 的默认栈大小意味着最多只能创建 1500 个线程。 

###

## 线程的创建、应答和终止

### 创建线程

当程序第一次运行并执行 `main()` 函数时，它是单线程。`pthread_create(t, attr, f, arg)` 定义和启动新的线程。启动新的线程时并不能保证哪个线程会先运行：是新创建的线程，还是调用线程？



### 线程号码

＂线程号码＂类似于＂进程号码＂，但是＂进程号码＂是由内核分配的，而＂线程号码＂是由 Pthreads 库分配的。＂线程号码＂以 `pthread_t` 类型表示。

SUSv3 并未要求将 `pthread_t` 定义为标量类型，在平台实现中也有可能是一个指针或结构。Linux 将 `pthread_t` 定义为 `unsigned long`，Solaris 将 `pthread_t` 定义为 `unsigned int`。FreeBSD 8.0 和 Mac OS X 10.6.8 将`pthread_t` 定义为一个指向 `pthread` 结构的指针。为了可移植，比较两个 `pthread_t` 时应该使用 `pthread_equal()`。 



### 线程属性

创建线程时可以指定线程的属性，各平台实现对线程属性的支持情况：
 
<table>
<tr>
  <th class="ta-c" style="min-width:110px">名称</th>
  <th class="ta-c" style="min-width:90px">描述</th>
  <th class="ta-c" style="min-width:110px">FreeBSD 8.0</th>
  <th class="ta-c" style="min-width:110px">Linux 3.2.0</th>
  <th class="ta-c" style="min-width:150px">Mac OS X 10.6.8</th>
  <th class="ta-c" style="min-width:100px">Solaris 10</th>
</tr>
<tr>
  <td class="ta-l">detachstate</td>
  <td class="ta-l">线程的分离状态属性</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">guardsize</td>
  <td class="ta-l">线程栈尾端的警戒缓冲区大小</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">stackaddr</td>
  <td class="ta-l">线程栈的最低地址</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">stacksize</td>
  <td class="ta-l">线程栈的最小长度</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
</table>



### 线程终止

线程可能会在某些情况下终止，所有这些情况都和进程终止类似：

* 如果线程通过线程函数返回，该线程就结束。这和 `main()` 函数结束有点类似。
* 如果线程调用 `pthread_exit()`，它就会终止。这和调用 `exit()` 类似。
* 如果线程是被另一个线程通过 `pthread_cancel()` 取消，它就会终止。这和通过 `kill()` 发送 `SIGKILL` 信号类似。
* 当进程退出时，进程内的所有线程都会立即终止。



### 线程退出函数

线程可以安排退出时调用的函数，这与进程退出时可以调用 atexit() 类似。这样的函数称为线程清理函数。它们的执行顺序与注册时相反。



### 连接线程

`pthread_join()` 会等待指定的线程终止，如果线程已经终止则立刻返回，这种操作称为＂连接＂。一个线程可以＂连接＂多个线程，实际上，这往往是主线程等待其创建的线程的方式。

`pthread_join()` 类似 `waitpid()`，不过线程之间的关系是对等的，进程中的任意线程均可以调用 `pthread_join()` 连接其他线程。



### 分离线程

默认情况下，线程是可连接的。有时，程序员并不关心线程的返回状态，只是希望线程终止时能够自动清理并移除。在这种情况下，可以调用 `pthread_detach()` 将指定的线程设置为分离状态，也可以在启动线程时调用 `pthread_attr_setdetachstate()` 将线程属性设置为分离状态。

一旦线程处于分离状态，就不能再使用 `pthread_join()` 来连接和获取其状态，也无法使其重返可连接状态。



### 僵尸线程

如果线程不是分离状态，则必须使用 `pthead_join()` 进行连接。如果未能连接，那么线程终止时将产生僵尸线程，与僵尸进程的概念类似。除了浪费系统资源外，如果僵尸线程积累过多，应用将无法创建新的线程。       

###

## 互斥量

### 何谓互斥量？

线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的，必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正由其他线程修改的变量。

互斥是同步线程的一种方式，可以确保同一时刻仅有一个线程可以访问某项共享资源。



### 互斥量属性

动态初始化互斥量时可以指定互斥的属性。互斥量属性中，值的注意的 3 个属性是：＂进程共享＂、＂健壮＂、＂类型＂。



### 互斥量属性 __ 进程共享

POSIX.1 中，＂进程共享＂属性是可选的。可以在编译期使用 `#if defined(_POSIX_THREAD_PROCESS_SHARED)` 检查符号表来判断平台是否支持＂进程共享＂。
也可以在运行期调用 `sysconf(_SC_THREAD_PROCESS_SHARED)` 来判断平台是否支持＂进程共享＂。
虽然这个选项并不是遵循 POSIX 标准的操作系统必需提供的，但是 SUS 要求遵循 XSI 标准的操作系统必须支持这个选项。

在进程中，多个线程可以访问同一个互斥量，这是默认的行为。在这种情况下，进程共享属性需要设置为`PTHREAD_PROCESS_PRIVATE` 。

存在这样的机制：允许相互独立的多个进程把同一块内存映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样，多个进程访问共享数据也需要同步。如果进程共享属性设置为 `PTHREAD_PROCESS_SHARED`，多个进程就可以通过存储在共享内存中的该互斥量进行同步。    



### 互斥量属性 __ 健壮

互斥量的健壮属性与在多个进程间共享的互斥量有关。这意味着，当持有互斥量的进程终止时，需要解决互斥量状态恢复的问题。这种情况发生时，互斥量处于锁定状态，恢复起来很困难。其它阻塞在这个锁的进程将会一直阻塞下去。健壮属性值有两种可能，默认值是 `PTHREAD_MUTEX_STALLED`，表示持有互斥量的进程终止时不需要采取特别的动作。这种情况下，使用互斥量后的结果是未定义的，等待该互斥量解锁的应用程序会被有效地＂拖住＂。另一个取值是 `PTHREAD_MUTEX_ROBUST`，这个值将导致线程调用 `pthread_mutext_lock()` 获取锁，而该锁被另一个进程持有，但它终止时并没有对该锁进行解锁，此时线程会阻塞，`从 pthread_mutex_lock()` 返回的值为 `EOWNERDEAD` 而不是 `0` 。应用程序可以通过这个特殊的返回值获知，若有可能，不管它们保护的互斥量状态如何，都需要进行恢复。

使用健壮的互斥量改变了我们使用 `pthread_mutex_lock()` 的方式，因为现在必须检查 3 个返回只而不是之前的两个：不需要恢复的成功、需要恢复的成功、失败。

在当前 4 个平台中，只有 Linux 3.2.0 和 Solaris 11 支持健壮的线程互斥量。



### 互斥量属性 __ 类型

类型属性控制互斥量的锁定特性，POSIX.1 定义了 4 种类型：

<table>
<tr>
  <th style="min-width:260px">类型</th>
  <th>描述</th>
</tr>
<tr>
  <td>PTHREAD_MUTEX_NORMAL</td>
  <td>标准互斥量类型，不做任何特殊的错误检查和死锁检测</td>
</tr>
<tr>
  <td>PTHREAD_MUTEX_ERRORCHECK</td>
  <td>提供错误检查</td>
</tr>
<tr>
  <td>PTHREAD_MUTEX_RECURSIVE</td>
  <td>允许同一线程在互斥量解锁前对互斥量进行多次加锁。递归互斥量维护一个锁的计数器，在解锁次数和加锁次数不相同的情况下，不会释放锁</td>
</tr>
<tr>
  <td>PTHREAD_MUTEX_DEFAULT</td>
  <td>提供默认特性和行为。操作系统在实现的时候可以把该类型自由地映射到其他类型中的一种。比如 Linux 3.2.0 映射为标准类型，FreeBSD 8.0 则映射为错误检查类型</td>
</tr>
</table>

这 4 种类型的行为如图：

互斥量类型| 没有加锁时重新加锁|不占用时解锁|在已解锁时解锁
-|-|-|-
PTHREAD_MUTEX_NORMAL|死锁|未定义|未定义
PTHREAD_MUTEX_ERRORCHECK|返回错误|返回错误|返回错误
PTHREAD_MUTEX_RECURSIVE|允许|返回错误|返回错误
PTHREAD_MUTEX_DEFAULT|未定义|未定义|未定义

###

## 读写锁

### 何谓读写锁？

读写锁与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有 3 种状态：读模式下加锁状态、写模式下加所状态、不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占用读模式的读写锁。

当读写锁是写加锁状态时，所有试图对其加锁的线程都会阻塞。当读写锁在读加锁状态时，所有试图以读模式对其进行加锁的线程都可以得到访问权，但是任何试图以写模式对其进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。

当读写锁处于读锁状态时，如果有线程试图以写模式获取锁时会阻塞，而且读写锁也会阻塞后续的读锁请求。这样可以避免读模式锁的长期占用，而等待的写模式锁请求一直得不到满足。



### 读写锁属性

动态初始化读写锁时可以指定读写锁属性。读写锁唯一支持的属性是＂进程共享＂，与互斥量的进程共享属性相同。

###

## 条件变量

### 何谓条件变量？

条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量允许一个线程就某个共享资源的状态变化通知其他线程。



### 条件变量属性

动态初始化条件变量时可以指定条件变量属性。条件变量支持＂进程共享＂属性和＂时钟＂属性。＂进程共享＂控制着条件变量是可以被单进程的多个线程使用，还是可以被多进程的线程使用。＂时钟＂属性控制计算`pthread_cond_timedwait()` 的超时时间采用的时钟类型。

## 自旋锁

自旋锁和互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。自旋锁可用在以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。

自旋锁通常作为底层原语用于实现其他类型的锁。当自旋锁用在非抢占式内核中时是非常有用的，但是在抢占式内核以及用户层并不是非常有用。

很多互斥量的实现非常高效，以至于应用程序采用互斥锁的性能和采用自旋锁的性能基本是相同的。

###

## 屏障

### 何谓屏障？

屏障使用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。`pthread_join()` 就是一种屏障，允许一个线程等待，直到另一个线程退出。

但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程到达屏障后可以接着工作。



### 屏障属性

动态初始化屏障时可以指定屏障属性。目前屏障只支持＂进程共享＂属性，控制屏障是可以被单进程的多个线程使用，还是可以被多进程的线程使用。

###

## 只初始化一次

`pthread_once(once, init)` 确保无论有多少线程调用 `pthread_once()`，只会执行一次由 `init` 指向的函数。

## 线程安全

### 何谓线程安全？

如果函数可同时被多个线程安全调用，则称之为线程安全函数，否则函数是线程不安全的，不能并发调用。

实现线程安全有多种方式。其一是将函数与互斥量关联使用，调用函数时将其锁定，函数返回时解锁。这一方式的优点在于简单。另一方面，这也意味着同时只能有一个线程执行该函数，对该函数的访问是串行的，多个线程无法在此函数内部并行。

另一种更为复杂的方案是将共享变量和互斥量关联。这需要程序员确认函数的哪些部分是使用了共享变量的临界区，并且只有在执行到临界区时才去获取和释放互斥量。这允许多个线程同时执行一个函数，只有在临界区才会变成串行。



### 可重入和不可重入

比起对整个函数使用互斥量，使用共享变量关联虽然有明显改进，但由于存在对互斥量的频繁加锁和解锁开销，所以多少还是有些低效。可重入函数则无需使用互斥量即可实现线程安全。其要诀在于避免对全局变量和静态变量的使用！！！

需要返回给调用者的任何信息，或者需要在对函数的历次调用期间加以维护的信息，都存储在由调用者分配的缓冲区内。不过，并非所有函数都可以实现为可重入。通常原因如下：

* 有些函数必须访问全局数据结构。`malloc()` 函数库中的函数就是这方面的典范。这些函数为堆中的空闲块维护一个全局链表。`malloc()` 库函数中的线程安全是通过互斥量来实现的。

* 一些函数的接口本身就定义为不可重入，要么返回指针，指向由函数自身静态分配的存储空间，要么利用静态存储对该函数历次调用期间的信息加以维护。比如 `asctime()` 返回一个指针，指向经由静态分配的缓冲区，其内容为日期和时间字符串。

对于一些接口不可重入的函数，SUSv3 为其定义了以后缀 **_r** 结尾的可重入版本。这些可重入版本要求由调用者来分配缓冲区，并将缓存区地址传递给函数用以返回结果。这使得调用线程可以使用局部（栈）变量来存放函数结果。出于这一目的，SUSv3 定义了如下函数： `asctime_r()` `ctime_r()` `getgrgid_r()` `getgnam_r()` `getlogin_r()` `getpwnam_r()` `getpwuid_r()` `gmtime_r()` `localtime_r()` `rand_r()` `readdir_r()` `strerror_r()` `strtok_r()` `ttyname_r()` 。



### 线程持有数据

使用线程持有数据，可以无需修改函数接口从而实现函数的线程安全。较之于可重入函数。采用线程持有数据的效率可能要略低一些，不过对于使用了这些调用的程序而言，则省去了修改程序的辛苦。

采用线程持有数据的函数，为每个调用线程分别维护一份变量的副本。在同一线程对相同函数的历次调用期间，每个线程的变量会持续存在，函数可以向每个调用线程返回各自的结果缓冲区（如果需要的话）。

### 线程持有数据的函数特征

* 函数必须为每个调用线程分配单独的存储，并且只需要在线程初次调用此函数时分配一次即可。
* 在同一线程对此函数的后续调用中，该函数都需要获取初次调用时线程分配的存储块地址。
* 线程退出时，释放为线程分配的存储。



### 线程局部存储

类似于线程持有数据，线程局部存储提供了持久的每线程存储。

线程局部存储的主要优点在于，比线程持有数据的使用简单。要创建线程局部变量，只需要简单的在全局或者静态变量的声明中包含 `__thread` 说明符即可：

```
  static __thread char buf[MAX_ERROR_LEN];
```

只要有这种说明符的变量，每个线程都拥有一份对变量的拷贝。线程局部存储中的变量将一直存在，直到线程终止，解释会自动释放这一存储。

### 需要注意的

* 如果变量声明中使用了关键字 `static` 或者 `extern`，那么关键字 `__thread` 必须紧随其后。
* 与一般的全局变量或者静态变量声明一样，线程局部变量在声明时可设置一个初始值。
* 可以使用 C 语言取址操作符(`&`)来获取线程局部变量的地址。



### 线程局部存储的支持

线程局部存储需要内核（Linux 2.6 提供）、Pthreads 实现（NPTL 提供）和 C 编译器（在 x86-32 平台上由 gcc 3.3 或后续版本提供）的支持。

```
#define _GNU_SOURCE        // 激活 <stdio.h的 _sys_nerr 和 _sys_errlist

#include <stdio.h>
#include <string.h>
#include <pthread.h>

#define MAX_ERROR_LEN 256

static __thread char buf[MAX_ERROR_LEN];

char *strerror(int err) {
    if (err < 0 || err >= _sys_nerr || _sys_errlist[err] == NULL)
        snprintf(buf, MAX_ERROR_LEN, "Unknow error %d", err);
    else {
        strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);
        buf[MAX_ERROR_LEN - 1] = '�';
    }
    return buf;
}
```

### 

## 线程限制

SUS 定义了与线程操作有关的限制，这些限制也可以通过 `sysconf(_SC_NAME)` 查询。

<table>
<tr>
  <th style="min-width:300px">限制名称</th>
  <th>描述</th>
  <th style="min-width:320px">name</th>
</tr>
<tr>
  <td>PTHREAD_DESTRUCTOR_ITERATIONS</td>
  <td>线程退出时操作系统实现试图销毁线程特定数据的最大次数</td>
  <td>_SC_THREAD_DESTRUCTOR_ITERATIONS</td>
</tr>
<tr>
  <td>PTHREAD_KEYS_MAX</td>
  <td>进程可以创建的键的最大数目</td>
  <td>_SC_PTHREAD_KEYS_MAX</td>
</tr>
<tr>
  <td>PTHREAD_STACK_MIN</td>
  <td>一个线程的栈可用的最小字节数</td>
  <td>_SC_PTHREAD_STACK_MIN</td>
</tr>
<tr>
  <td>PTHREAD_THREADS_MAX</td>
  <td>进程可以创建的最大线程数</td>
  <td>_SC_PTHREAD_THREADS_MAX</td>
</tr>
</table>

与 `sysconf()` 报告的其他限制一样，这些限制的目的是为了增强应用程序在不同的操作系统实现之间的可移植性。下图给出了 4 种操作系统实现中线程限制的值。

限制名称|FreeBSD 8.0|Linux 3.2.0 | Max OS X 10.6.8 | Solaris10
-------|-----------|------------|-----------------|-----------
PTHREAD_DESTRUCTOR_ITERATIONS|4|4|4|不确定的
PTHREAD_KEYS_MAX|256|1024|512|不确定的
PTHREAD_STACK_MIN|2048|16384|8192|8192
PTHREAD_THREADS_MAX|不确定的|不确定的|不确定的|不确定的

## 记录锁

### 何谓记录锁？

当第一个进程正在读或写文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。记录锁也可以称为“字节范围锁”，因为它锁定的只是文件中的一个区域（也可能是整个文件）。

POSIX.1 标准的记录锁的基础是 `fcntl()` 系统调用。下表列出了各系统提供的不同形式的记录锁：

<table>
<tr>
  <th class="ta-c" style="min-width:110px">锁</th>
  <th class="ta-c" style="min-width:90px">SUS</th>
  <th class="ta-c" style="min-width:110px">FreeBSD 8.0</th>
  <th class="ta-c" style="min-width:110px">Linux 3.2.0</th>
  <th class="ta-c" style="min-width:150px">Mac OS X 10.6.8</th>
  <th class="ta-c" style="min-width:100px">Solaris 10</th>
</tr>
<tr>
  <td class="ta-l">建议性</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">强制性</td>
  <td class="ta-c"></td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">fcntl()</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">lockf()</td>
  <td class="ta-c">XSI</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
<tr>
  <td class="ta-l">flock()</td>
  <td class="ta-c"></td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
  <td class="ta-c">•</td>
</tr>
</table>



### 锁区域

在设置或者释放文件上的一把锁时，系统按要求组合或者分裂相邻区。比如，如果第 100~199 字节是加锁的区域，需要解锁第 150 字节，则内核将维持两把锁，一把用于第 100~149 字节，一把用于 151~199 字节。
>
```
#|                  ××××××××××××××××××××××××××××××××      
#|                  ×            加锁区             ×       
#|                  ××××××××××××××××××××××××××××××××  
#|                  100                           199        
#|
#|                  ××××××××××××××××××××××××××××××××      
#|                  ×  第一加锁区  ×   ×  第二加锁区  ×       
#|                  ××××××××××××××××××××××××××××××××  
#|                  100          149 150          199   
``` 

假定我们又对第 150 字节加锁，那么系统将会再把 3 个相邻的加锁区合并成一个区（第 100~199 字节）。

###

## 进程间通信

### UNIX IPC 支持形式

<table>
<tr>
  <th class="ta-c">IPC 类型</th>
  <th class="ta-c">SUS</th>
  <th class="ta-c">FreeBSD 8.0</th>
  <th class="ta-c">Linux 3.2.0</th>
  <th class="ta-c">Mac OS X 10.6.8</th>
  <th class="ta-c">Solaris 10</th>
</tr>
<tr>
    <td>半双工管道FIFO</td>
    <td class="ta-c">••</td>
    <td class="ta-c">（全）•</td>
    <td class="ta-c">••</td>
    <td class="ta-c">••</td>
    <td class="ta-c">（全）•</td>
</tr>
<tr>
    <td>全双工管道命名全双工管道</td>
    <td class="ta-c">允许废弃的</td>
    <td class="ta-c">•. UDSUDS</td>
    <td class="ta-c">UDSUDS</td>
    <td class="ta-c">UDSUDS</td>
    <td class="ta-c">•. UDS•. UDS</td>
</tr>
<tr>
    <td>XSI 消息队列XSI 信号量XSI 共享存储</td>
    <td class="ta-c">XSIXSIXSI</td>
    <td class="ta-c">•••</td>
    <td class="ta-c">•••</td>
    <td class="ta-c">•••</td>
    <td class="ta-c">•••</td>
</tr>
<tr>
    <td>消息队列（实时）信号量共享存储（实时）</td>
    <td class="ta-c">MSG 选项SHM 选项</td>
    <td class="ta-c">•••</td>
    <td class="ta-c">•••</td>
    <td class="ta-c">••</td>
    <td class="ta-c">•••</td>
</tr>
<tr>
    <td>套接字STREAMS</td>
    <td class="ta-c">•废弃的</td>
    <td class="ta-c">•</td>
    <td class="ta-c">•</td>
    <td class="ta-c">•</td>
    <td class="ta-c">•</td>
</tr>
</table>

* （全） - 使用全双工管道支持半双工管道
* UDS - 使用 UNIX 域套接字支持
* •. UDS - 使用管道和 UNIX 套接字支持



### 管道

`pipe(fd[2])` 创建一对管道，返回两个文件描述符号码，第一个用于读，第二个用于写。管道是 UNIX IPC 的最古老形式，所有　UNIX 都提供此种通信机制。

可以使用 `fstat()` 测试管道的文件类型：`S_ISFIFO`。



### 管道的局限

* 半双工，要么只能读，要么只能写
* 只能在具有公共祖先的进程之间使用，不相关的进程之间无法使用



### 管道的优点

1. 管道中传输的是字节流，写入的顺序和读取的顺序是一致的
2. 管道中不会丢失数据，除非读取端提前关闭读取管道



### 关闭不需要的管道端

在父子进程分别关闭了不需要的＂文件描述符表＂，虽然不是必须的，但是＂打开的文件＂是有上限的，尽可能的关闭不使用的总是好的。

`close()` 只会减少内核缓冲中保存的＂文件资源＂的引用计数，而不是真的关闭＂文件资源＂。当引用计数变为 0 的时候，才会真正关闭＂文件资源＂。同样的，每次 `open()` 或者以其他方式打开一个＂文件资源＂时，也会把引用计数加 1。



### 读写管道

* 读一个写端已关闭的管道，在所有数据都被读取后，返回 0，表示文件结束
* 写一个读端已关闭的管道，产生 **SIGPIPE** 信号。如果忽略该信号，或者捕捉该信号并从其处理程序返回，`write` 返回 -1，**errno** 置为 **EPIPE**

`PIPE_BUF` 常量，规定了内核的管道缓冲区大小。



### 管道死锁

在更复杂的程序中，你可能需要一个双向通信的管道，那么你必须建立两对管道：每一个进程使用两个端进行读和写。这时候你必须要小心，因为这样使用管道很容易＂死锁＂。我们没有用锁，怎么会出现＂死锁＂？事实上，这种情况只是跟＂死锁＂相同的表现。
>
            进程 A                  进程 B
     
        pipefds_a[1] ----------pipefds_a[0]
        pipefds_b[0] <---------- pipefds_b[1]

比如在上图中，进程 A 和进程 B 分别通过一对管道进行读写。

1. 假设进程 A 使用 pipefds_b[0，阻塞在读取时，进程 B 也使用 pipefds_b[1] 阻塞在读取。这时候，两边都没有字节流发送，进程 A 和进程 B 就会一直阻塞在那里，什么都不做了。

2. 假设进程 A 使用 pipefds_a[1] 写入。基于字节流的读写往往都是基于内核缓冲区，管道也不例外。当创建管道的时候，内核同时为管道分配了一块内存缓冲，管道写入的时候会写入到这块内核缓冲区上，管道读取的时候也会从这块内核缓冲区读走数据。如果写入的数据很大，内核缓冲区已经填满了，那么进程 A 就会阻塞在那，等待内核缓冲区清空，继续写入。然而此时，进程 B 并没有读取数据，也在使用 pipefds_b[1] 写入管道的内核缓冲区，也阻塞在那里。这样，两个进程也同时阻塞，什么都不做了。

建议：可能的话，把管道读写设置为非阻塞的。



### 命名管道

管道有一个限制：只能在相关进程之间使用。在不相干的进程之间通信，可以使用命名管道 FIFO。打开一个文件，然后进行写入数据，写入完毕关闭，另外一个进程就可以打开同一个文件进行读取数据。

说白了，管道是使用内存交换数据，命名管道使用一个实际的文件交换数据。操作一个命名管道和操作一个普通文件非常相似。另外，命名管道不能够同时读和写，要么读，要么写，每一个操作只能等待另一个的完成。因为是对文件的操作，需要有文件的读写权限。



### 读写命名管道

从一个命名管道读取时，如果没有数据，会阻塞，而不是立刻返回 EOF（这与普通文件的读不同）。当命名管道写入时，如果内核缓冲区塞满了，但是没有消费者（读取），进程会阻塞在那，直到内核缓冲区的数据被读取清空。

`PIPE_BUF` 常量，规定了内核的管道缓冲区大小。

建议：可能的话，把命名管道读写设置为非阻塞的。



### 域套接字 socketpair

这是一个非常好用的通信方式，跟管道是非常相似，甚至工作方式接近相同，但是拥有非常棒的优点：进程之间可以是不相关的，通信方式是双向的（管道是单向的）。

建议：对于进程间通信，这是一个非常效率稳定的方式，你也可以将其设置为非阻塞的。



### 内存映射

`mmap()` 在虚拟内存空间创建一个内存映射，映射的内存可以与其他进程共享：

* 映射同一个文件同一个区域，共享相同的＂物理内存页＂
* 通过 `fork()` 创建的子进程，会复制父进程的＂内存页＂，可以在这些内存页中映射共享内存

在读设备 */dev/zero* 时，该字符设备是 0 字节的无限资源，它也接受写入的任何数据，但是会忽略这些数据。将该设备用作 IPC 进行内存映射时，该设备会：
>
* 创建一个未命名的存储区，长度是 `mmap` 第二个参数，向上取整为系统的最近页长
* 存储区初始化为 0
* 如果多个进程的共同祖先进程，对 `mmap` 指定了 `MAP_SHARED` 标志则这些进程可共享此存储区

### 更多进程通信方式

还有一些进程通信方式，包括但不限于：

* 消息队列
* 信号量
* 共享内存（类似于 mmap，但是可移植较差）

###

## 伪终端

## 信号

## 日期和时间

### 进程时间

进程时间（CPU 时间），度量进程使用的 CPU 资源。以时钟滴答计算，每秒钟曾经取为 50，60，100 个时钟滴答。以类型 `clock_t` 表示。

度量一个进程的执行时间时，UNIX 为进程维护 3 个进程时间值：

* 时钟时间，（墙上时间），进程运行的时间总量，与系统中同时运行的进程数有关。
* 用户 CPU 时间，执行用户指令使用的时间量。
* 系统 CPU 时间，执行内核程序使用的时间。

`$ time ./test`，取得进程的时间：

      real om0.81s
      user om0.11s
      sys  om0.07s 



### 日历时间

日历时间，自协调世界时间（UTC，自公元 1970 年 1 月 1日 00:00:00）经过的秒数。这种秒数是以类型 `time_t` 表示。

POSIX.1 实时扩展增加了对多个系统时钟的支持。时钟通过 `clockid_t` 类型标识：

<table>
<tr>
  <th class="ta-c">标识符</th>
  <th class="ta-c">选项</th>
  <th class="ta-c">说明</th>
</tr>
<tr>
  <td>CLOCK_REALTIME</td>
  <td></td>
  <td>实时的系统时间</td>
</tr>
<tr>
  <td>CLOCK_MONOTONIC</td>
  <td>_POSIX_MONOTONIC_CLOCK</td>
  <td>不带负跳数的实时系统时间</td>
</tr>
<tr>
  <td>CLOCK_PROCESS_CPUTIME_ID</td>
  <td>_POSIX_CPUTIME</td>
  <td>调用进程的 CPU 时间</td>
</tr>
<tr>
  <td>CLOCK_THREAD_CPUTIME_ID</td>
  <td>_POSIX_THREAD_CPUTIME</td>
  <td>调用线程的 CPU 时间</td>
</tr>
</table>

###

## 错误处理

### 何谓错误处理？

在系统编程中，错误是通过函数的返回值和特殊变量 `errno` 描述。Glibc 为库函数和系统调用提供透明 `errno` 支持。

函数通过特殊返回值（通常是 `-1`，具体值取决于函数）通知调用函数发生了错误。错误之告诉调用函数发生了错误，但是并没有给出错误发生的原因。变量 `errno` 用于定位错误的原因。



### errno

`errno` 在 `<errno.h>` 中定义如下： `extern int errno;` 。可以直接读写 `errno` 变量，它是可修改的左值。`errno` 的值和特定错误的文本描述一一对应。预处理器 `#define` 也和 `errno` 数值一一对应。

C 提供了很多函数，可以把 `errno` 值转换成对应的文本。


```
//    E2BIG           -  Argument list too long (POSIX.1)
//    EACCES          -  Permission denied (POSIX.1)
//    EADDRINUSE      -  Address already in use (POSIX.1)
//    EADDRNOTAVAIL   -  Address not available (POSIX.1)
//    EAFNOSUPPORT    -  Address family not supported (POSIX.1)
//    EAGAIN          -  Resource  temporarily unavailable (may be the
//                       same value as EWOULDBLOCK) (POSIX.1)
//    EALREADY        -  Connection already in progress (POSIX.1)
//    EBADE           -  Invalid exchange
//    EBADF           -  Bad file descriptor (POSIX.1)
//    EBADFD          -  File descriptor in bad state
//    EBADMSG         -  Bad message (POSIX.1)
//    EBADR           -  Invalid request descriptor
//    EBADRQC         -  Invalid request code
//    EBADSLT         -  Invalid slot
//    EBUSY           -  Device or resource busy (POSIX.1)
//    ECANCELED       -  Operation canceled (POSIX.1)
//    ECHILD          -  No child processes (POSIX.1)
//    ECHRNG          -  Channel number out of range
//    ECOMM           -  Communication error on send
//    ECONNABORTED    -  Connection aborted (POSIX.1)
//    ECONNREFUSED    -  Connection refused (POSIX.1)
//    ECONNRESET      -  Connection reset (POSIX.1)
//    EDEADLK         -  Resource deadlock avoided (POSIX.1)
//    EDEADLOCK       -  Synonym for EDEADLK
//    EDESTADDRREQ    -  Destination address required (POSIX.1)
//    EDOM            -  Mathematics argument out of domain  of  func‐
//                       tion (POSIX.1, C99)
//    EDQUOT          -  Disk quota exceeded (POSIX.1)
//    EEXIST          -  File exists (POSIX.1)
//    EFAULT          -  Bad address (POSIX.1)
//    EFBIG           -  File too large (POSIX.1)
//    EHOSTDOWN       -  Host is down
//    EHOSTUNREACH    -  Host is unreachable (POSIX.1)
//    EIDRM           -  Identifier removed (POSIX.1)
//    EILSEQ          -  Illegal byte sequence (POSIX.1, C99)
//    EINPROGRESS     -  Operation in progress (POSIX.1)
//    EINTR           -  Interrupted function call (POSIX.1); see sig‐
//                       nal(7).
//    EINVAL          -  Invalid argument (POSIX.1)
//    EIO             -  Input/output error (POSIX.1)
//    EISCONN         -  Socket is connected (POSIX.1)
//    EISDIR          -  Is a directory (POSIX.1)
//    EISNAM          -  Is a named type file
//    EKEYEXPIRED     -  Key has expired
//    EKEYREJECTED    -  Key was rejected by service
//    EKEYREVOKED     -  Key has been revoked
//    EL2HLT          -  Level 2 halted
//    EL2NSYNC        -  Level 2 not synchronized
//    EL3HLT          -  Level 3 halted
//    EL3RST          -  Level 3 halted
//    ELIBACC         -  Cannot access a needed shared library
//    ELIBBAD         -  Accessing a corrupted shared library
//    ELIBMAX         -  Attempting  to  link  in  too   many   shared
//                       libraries
//    ELIBSCN         -  lib section in a.out corrupted
//    ELIBEXEC        -  Cannot exec a shared library directly
//    ELOOP           -  Too many levels of symbolic links (POSIX.1)
//    EMEDIUMTYPE     -  -  Wrong medium type
//    EMFILE          -  Too many open files (POSIX.1)
//    EMLINK          -  Too many links (POSIX.1)
//    EMSGSIZE        -  Message too long (POSIX.1)
//    EMULTIHOP       -  Multihop attempted (POSIX.1)
//    ENAMETOOLONG    -  Filename too long (POSIX.1)
//    ENETDOWN        -  Network is down (POSIX.1)
//    ENETRESET       -  Connection aborted by network (POSIX.1)
//    ENETUNREACH     -  Network unreachable (POSIX.1)
//    ENFILE          -  Too many open files in system (POSIX.1)
//    ENOBUFS         -  No   buffer  space  available  (POSIX.1  (XSI
//                       STREAMS option))
//    ENODATA         -  No message is available on  the  STREAM  head
//                       read queue (POSIX.1)
//    ENODEV          -  No such device (POSIX.1)
//    ENOENT          -  No such file or directory (POSIX.1)
//    ENOEXEC         -  Exec format error (POSIX.1)
//    ENOKEY          -  Required key not available
//    ENOLCK          -  No locks available (POSIX.1)
//    ENOLINK         -  Link has been severed (POSIX.1)
//    ENOMEDIUM       -  No medium found
//    ENOMEM          -  Not enough space (POSIX.1)
//    ENOMSG          -  No message of the desired type (POSIX.1)
//    ENONET          -  Machine is not on the network
//    ENOPKG          -  Package not installed
//    ENOPROTOOPT     -  Protocol not available (POSIX.1)
//    ENOSPC          -  No space left on device (POSIX.1)
//    ENOSR           -  No  STREAM  resources  (POSIX.1  (XSI STREAMS
//                       option))
//    ENOSTR          -  Not a STREAM (POSIX.1 (XSI STREAMS option))
//    ENOSYS          -  Function not implemented (POSIX.1)
//    ENOTBLK         -  Block device required
//    ENOTCONN        -  The socket is not connected (POSIX.1)
//    ENOTDIR         -  Not a directory (POSIX.1)
//    ENOTEMPTY       -  Directory not empty (POSIX.1)
//    ENOTSOCK        -  Not a socket (POSIX.1)
//    ENOTSUP         -  Operation not supported (POSIX.1)
//    ENOTTY          -  Inappropriate I/O control operation (POSIX.1)
//    ENOTUNIQ        -  Name not unique on network
//    ENXIO           -  No such device or address (POSIX.1)
//    EOPNOTSUPP      -  Operation not supported on socket (POSIX.1)
//                       (ENOTSUP and EOPNOTSUPP have the  same  value
//                       on  Linux,  but  according  to  POSIX.1 these
//                       error values should be distinct.)
//    EOVERFLOW       -  Value too large to be  stored  in  data  type
//                       (POSIX.1)
//    EPERM           -  Operation not permitted (POSIX.1)
//    EPFNOSUPPORT    -  Protocol family not supported
//    EPIPE           -  Broken pipe (POSIX.1)
//    EPROTO          -  Protocol error (POSIX.1)
//    EPROTONOSUPPORT -  Protocol not supported (POSIX.1)
//    EPROTOTYPE      -  Protocol wrong type for socket (POSIX.1)
//    ERANGE          -  Result too large (POSIX.1, C99)
//    EREMCHG         -  Remote address changed
//    EREMOTE         -  Object is remote
//    EREMOTEIO       -  Remote I/O error
//    ERESTART        -  Interrupted system call should be restarted
//    EROFS           -  Read-only filesystem (POSIX.1)
//    ESHUTDOWN       -  Cannot send after transport endpoint shutdown
//    ESPIPE          -  Invalid seek (POSIX.1)
//    ESOCKTNOSUPPORT -  Socket type not supported
//    ESRCH           -  No such process (POSIX.1)
//    ESTALE          -  Stale file handle (POSIX.1)
//                       This  error  can  occur for NFS and for other
//                       filesystems
//    ESTRPIPE        -  Streams pipe error
//    ETIME           -  Timer expired (POSIX.1 (XSI STREAMS option))
//                       (POSIX.1 says "STREAM ioctl(2) timeout")
//    ETIMEDOUT       -  Connection timed out (POSIX.1)
//    ETXTBSY         -  Text file busy (POSIX.1)
//    EUCLEAN         -  Structure needs cleaning
//    EUNATCH         -  Protocol driver not attached
//    EUSERS          -  Too many users
//    EWOULDBLOCK     -  Operation would block (may be same  value  as
//                       EAGAIN) (POSIX.1)
//    EXDEV           -  Improper link (POSIX.1)
//    EXFULL          -  Exchange full
```

###

## 系统信息

数据文件 */proc*，存放了进程信息。*/proc/${PID}/* 的内容：

* cmdline - 命令行参数
* cwd - 指向当前工作目录的符号链接
* environ - NAME=value 环境列表
* exe - 指向正在执行文件的符号链接
* fd - 为进程打开的每个文件描述符，都包含一个符号链接。每个进程都可以使用符号链接 /proc/self 访问自己的 /proc/${PID} 目录
* maps - 内存映射
* mem - 进程虚拟内存
* mounts - 进程的安装点
* root - 指向根目录的符号链接
* status - 相关信息（进程号码，进程证书，内存使用量，信号）
* task - 为进程中的每个线程均包含一个子目录<br >

## 系统限制

SUSv3 要求，对规范的每个限制，必须支持一个最小值。大多数情况，这些最小值定义在 `<limits.h>`，命名以 `_POSIX_`，通常还包含字符串 `_MAX`，比如 `_POSIX_XXX_MAX`。限制主要有 3 类：
>
* 运行时恒定值
* 运行时可增加值
* 路径名变量值

## 可移植性

系统调用和库函数 API 的行为受各种标准的制约。这些标准中的一部分是由 Open Group (SUS) 这样的标准机构来制定的，而另一部分则是由具有重要历史意义的两个 UNIX 实现 BSD 和 System V Release 4 （以及相关的 System V 接口定义） 来定义。

编写可移植性应用程序时，有时会希望各个头文件只暴露遵循特定标准的定义。要达到这一目的，在编译程序时需要定义下列一个或者多个特性测试宏。

方式之一是在程序源码包含任何头文件之前，定义如下宏：

*`#define _BSD_SOURCE 1`*

此外，还可以使用 C 编译器的 `-D` 选项：

*`
  $ cc -D_BSD_SOURCE prog.c
`*



在不带任何特殊选项调用 GNU C 编译器时，默认定义 `_POSIX_SOURCE`、`_POSIX_C_SOURCE=200809`、`_BSD_SOURCE` 和 `SVID_SOURCE` 。

<table>
<tr>
  <td style="min-width:160px">`_POSIX_SOURCE`</td>
  <td>POSIX.1-1990 和 ISO C (1990) 标准的定义，该宏已被 `_POSIX_C_SOURCE` 取代</td>
</tr>
<tr>
  <td>`_POSIX_C_SOURCE`</td>
  <td>若定义为 `1`，效果同 `_POSIX_SOURCE`。若定义的值大于等于 `199309`，还会暴露遵从 POSIX.1b （实时） 标准的定义。若定义的之大于等于 `199506`，便会开启对 POSIX.1c （线程） 定义的支持。若定义的值为 `200809`，便会开启对 POSIX。1-2008 基本规范定义的支持。</td>
</tr>
<tr>
  <td>`_XOPEN_SOURCE`</td>
  <td>开启对 POSIX.1、POSIX.2 和 X/Open（XPG4） 标准的定义。若定义的值大于等于 `500`，还会开启对 SUSv2 （UNIX 98 和 XPG5） 扩展的支持。若定义的值大于等于 `600`，还会开启对 SUSv3 XSI （UNIX 03） 扩展和 C99 扩展的支持。若定义的值大于等于 `700`，还会开启对 SUSv4 XSI 扩展的支持。</td>
</tr>
<tr>
  <td>`_BSD_SOURCE`</td>
  <td>开启对 BSD 定义的支持。此外，只要定义了该宏，就会以值 `199506` 定义 `_POSIX_C_SOURCE`。</td>
</tr>
<tr>
  <td>`_SVID_SOURCE`</td>
  <td>开启符合 System V 接口规范的定义。</td>
</tr>
<tr>
  <td>`_GNU_SOURCE`</td>
  <td>开启上述所有标准的定义，并且开启对各种 GNU 扩展定义的支持。</td>
</tr>
</table>

###

## 目标库

### 构建程序

构建程序的一种方式是简单地将每一个源文件编译成目标文件，然后将这些目标文件链接在一起组成一个可执行程序：

*`
$ cc -g -c prog.c mod1.c mod2.c mod3.c
$ cc -g -o prgo_nolib prog.o mod1.o mod2.o mod3.o
`*



### 链接

链接实际上是由一个单独的链接器程序 **ld** 来完成的。当使用 **cc** （或 **gcc**） 命令链接一个程序时，编译器会在幕后调用 **ld** 。在 Linux 上应该总是通过 **gcc** 间接地调用连接器，因为 **gcc** 能够确保使用正确的选项来调用 **ld** 并将程序与正确的库文件链接起来。

在很多情况下，源代码文件也可以被多个程序共享。因此要降低工作量的第一步就是将这些源代码文件只编译一次，然后在需要的时候将它们链接进不同的可执行文件中。虽然这样做能够节省编译时间，但缺点是在链接的时候仍然需要为所有目标文件命名。此外，大量的目标文件会散落在系统的各个目录中，造成目录内容混乱。

为解决这个问题，可以将一组目标文件组织成一个称为对象库的单元。对象库分为两种：静态的和共享的。



### 在编译程序时包含调试器信息

在 **cc** 命令中使用 `-g` 选项可以在编译过的程序中包含调试信息。一般来讲，创建允许调试的程序和库是一种比较好的做法。此外，在一些架构上，比如 x86-32，不应该指定 `-fomit-frame-pointer` 选项，因为这会使得无法调试。

###

## 静态库

### 静态库

静态库也称为归档文件，能带来下列好处：

* 可以将一组经常使用的目标文件组织成单个库文件，这样就可以用它来构建多个可执行程序，并且在构建各个应用程序的时候不需要重新编译源代码文件。
* 链接命令变得更加简单。在链接命令行中只需要指定静态库的名称即可，而无需一个个的列出目标文件。链接器知道如何搜索静态库并将可执行程序需要的内容抽取出来。

静态库实际上是一个保存所有已添加的目标文件的副本文件。其中还记录了每个目标文件的各种特性，包括文件权限、用户号码、组号码、以及修改时间戳。静态库的名称形式为 **libname.a** 。



### 创建和维护静态库

使用 **ar** 命令创建和维护静态库：

*`
   $ ar options archive object-file ...
`*

options 参数由一系列字母构成，代表操作代码：

* `r` - 替换。将一个目标文件插入到归档文件中并取代同名的目标文件

       $ cc -g -c mod1.c mod2.c mod3.c
       $ ar r libdemo.a mod1.o mo2.o mod3.o
       $ rm mod1.o mod2.o mod3.o               // 删除目标文件，已经不再需要

* `t` - 目录表。显示归档中的目录表，默认情况只会列出归档文件中目标文件的名称。添加 `v` 修饰符后可以看到记录在归档文件中的各个目标文件的其他所有特性

       $ ar tv libdemo.o
       rw-r--r-- 1000/100 1001016 Nov 15 12:26 2009 mod1.o
       rw-r--r-- 1000/100  406668 Nov 15 12:21 2009 mod2.o
       rw-r--r-- 1000/100   46672 Nov 15 12:21 2009 mod3.o
         权限     uid/gid   size    lastmodify time     

* `d` - 删除。从归档文件中删除一个模块

       $ ar d libdemo.a mod3.o



### 链接静态库

将程序和静态库链接起来有两种方式：

1.在链接命令中指定静态库的名称

```
  $ cc -g -c prog.c
  $ cc -g -o prog prog.o libdemo.a
```

2.将静态库放在链接器搜索的标准目录中（如 */usr/lib*），然后使用 `-l` 选项指定库名

      $ cc -g -o prog prog.o -ldemo

　 如果静态库不在链接器的搜索目录中，可以使用 `-L` 指定链接器应该搜索这个额外的目录

```
  $ cc -g -o prog prog.o -Lmylibdir -ldemo
```

虽然一个静态库可以包含很多目标模块，但是链接器只会包含那些程序需要的模块。链接完程序后可以运行该程序：

```
  $ ./prog
  Called mod1-x1
  Called mod2-x2
```

###

## 共享库

### 静态库的问题

将程序与静态库链接起来时，得到的可执行文件会包含所有被链接进程序的目标文件的副本。这样当几个不同的可执行程序使用了同样的目标模块时，每个可执行程序都会拥有目标模块的副本。这种代码的冗余存在几个缺点：

* 存储同一个目标模块的多个副本会浪费磁盘空间，并且所浪费的空间是比较大的。
* 如果几个使用了同一模块的程序在同一时刻运行，那么每个程序会独立地在虚拟内存中保存一份目标模块的副本，消耗更多的虚拟内存。
* 如果需要修改一个目标模块，那么所有使用该模块的可执行文件都必须要重新进行链接以合并这个变更。



### 共享库

目标模块的单个副本由所有需要这些模块的程序共享。目标模块不会被复制到链接过的可执行文件中。当第一个需要共享库中的模块的程序启动时，库的单个副本就会在运行时加载进内存。当后面使用同一共享库的其他程序启动时，它们会使用已经被加载进内存的库的副本。使用共享库意味着可执行程序需要的磁盘空间和虚拟内存更少了。

虽然共享库的代码是由多个进程共享的，但其中的变量却不是的。每个使用库的进程会拥有自己的在库中定义的全局和静态变量的副本。

由于整个程序的大小变得更小了，因此在一些情况下，程序可以完全被加载进内存中，从而能够更快地启动程序。这一点只有在大型共享库正在被其他程序使用的情况下才成立。第一个加载共享库的程序实际上在启动时会花费更长的时间，因为必须要先找到共享库并将其加载进内存中。

由于目标模块没有被复制进可执行文件中，而是在共享库中集中维护，因此在修改目标模块时无需重新链接程序就能够看到变更，甚至在运行着的程正在使用共享库的现有版本的时候也能够进行这样的变更。



### 共享库的开销

* 比静态库更复杂。
* 在编译时必须使用位置独立的代码。
* 在运行时必须要执行符号重定位。在符号重定位期间，需要将对共享库中每个符号（变量或者函数）的引用修改成符号在虚拟内存中的实际运行时位置。由于存在这个重定位的过程，与静态链接程序相比，使用共享库的程序或多或少需要花费一些时间来执行这个过程。 



### 创建和使用共享库

使用 `-shared` 选项创建共享库：

```
  $ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c
  $ gcc -g -shared -o libfoo.so mod1.o mod2.o mod3.o
```

根据惯例，共享库的前缀为 lib，后缀为 .so 。可以将编译源代码文件和创建共享库放在一个命令中执行：


      $ gcc -g -fPIC -Wall mpd1.c mod2.c mod3.c -shared -o libfoo.so

      // -fPIC - 指定编译器应该生成位置独立的代码，这会改变编译器生成执行特定操作的代码的方式，包括
      //         全局、静态和外部变量，访问字符串常量，以及获取函数的地址。这些变更使代码可以在运行
      //         时被放置在任意一个虚拟地址处。
      //
      //         在一些架构上无法在不加 -fPIC 的情况下构建共享库。确定目标文件编译时是否使用了 -fPIC：
      //
      //           $ nm mod1.o | grep _GLOBAL_OFFSET_TABLE
      //           $ readelf -s mod1.o | grep _GLOBAL_OFFSET_TABLE 
      //         
      //         如下两个命令确定共享库至少存在一个目标模块在编译时没有指定 -fPIC
      //
      //           $ objump --all-headers libfoo.o | grep TEXTREL
      //           $ readelf -d libfoo.so | grep TEXTREL 



### 动态链接器

链接共享库需要通过动态链接器来完成。动态链接器本身也是一个共享库，其名称为 */lib/ld-linux.so.2*，所有使用共享库的 ELF 可执行文件都会用到这个共享库。*/lib/ld-linux.so.2* 通常是一个指向动态链接器可执行文件的符号链接。这个文件的名称为 */lib/ld-version.so*，其中 version 表示安装在系统上的 Glibc 的版本---如 ld-2.11.so。在不同架构上，动态链接器的路径名是不同的，如在 IA-64 上，动态链接器符号链接的名称为*/lib/ld-linux-ia64.so.2* 。

动态链接器会检查程序所需的共享库清单并使用一组预先定义好的规则来在文件系统上找出相关的库文件。其中一些规则指定了一组存放共享库的标准目录。如很多共享库位于 */lib* 和 */usr/lib* 中。（一些架构比如 zSeries、PowerPC64、x86-64 同时支持执行 32 位和 64 位的程序。在此类系统上，32 位的库位于 */lib* 和 */usr/lib*，64 位的库位于 */lib64* 和 */usr/lib64*。）

当一个共享库位于非标准目录时，可以将该目录添加到 `LD_LIBRARY_PATH` 环境变量中，来帮助动态链接器进行查找。如果定义了 `LD_LIBRARY_PATH`，那么动态链接器在查找标准库目录之前会先查找该环境变量列出的目录中的共享库。

```
  $ LD_LIBRARY_PATH=. ./prog   // 执行 prog，并在当前工作目录中搜索共享库
  Called mod1-x1
  Called mod2-x2
```



### soname
 
如果共享库拥有一个 soname,那么在静态链接阶段会将 soname 嵌入到可执行文件中，而不会使用真实名称，同时后面的动态链接器在运行时也会使用这个 soname 来搜索库。

引入 soname 是为了提供一个中间层，使可执行程序能在运行时和链接时使用不同的共享库。

```
  $ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c
  $ gcc -g -shared -Wl,-soname,libbar.so -o libfoo.so mod1.o mod2.o mod3.o
    // -Wl,-soname,libbar.so - 将共享库 libfoo.so 的 soname 设置为 libbar.so
```

使用如下命令确定一个共享库的 soname：

```
  $ objdump -p lifoo.so | grep SONAME
  SONAME    libfar.so
  $ readelf -d lifoo.so | grep SONAME
  0x0000000e (SONAME)   Library soname: [libfar.so]
```

在使用 soname 创建一个共享库后就可以照常创建可执行文件了：

```
  $ gcc -g -Wall -o prog prog.c libfoo.so
```

但这次链接器检查到库 libfoo.si 包含了 soname libfar.so，于是将这个 soname 嵌入到了可执行文件中。现在运行这个程序时会看到下面的输出：

```
  $ LD_LIBRARY_PATH=. ./prog
  prog: error in loading shared libaries: libbar.so: cannot open
  shared object file: No such file or directory
  // 无法找到名为 libbar.so 的共享库！！！
```

必须要创建一个符号链接将 soname 指向库的真实名称，并且将这个符号链接放在动态链接器搜索的目录中：

```
  $ ln -s libfoo.so libbar.so
  $ LD_LIBRARY_PATH=. ./prog
  Called mod1-x1
  Called mod2-x2
```



### 工具

* **ldd** - 显示程序运行需要的共享库：

```
  $ ldd ./prog
  libdemo.so.1 =/usr/lib/libdemo.so.1 (0x40019000)
  libc.so.6 =/lib/libc.so.6 (0x4017b000)
  /lib/ld-linux.so.2 =/lib/ld-linux.so.2 (0x40000000)
```

* **objdump** **readelf** - 显示各类信息---包括反汇编的二进制机器码---从一个可执行文件、编译过的目标以及共享库中。还能够用来显示文件中各个 ELF 节的头部信息。

* **nm** - 显示目标库或者可执行程序定义的一组符号：

```
  $ nm -A /usr/lib/lib.*.so 2/dev/null | grep ' crypt$'
  // 找出定义了 crypt() 函数的共享库
```



### 版本

共享库的每个不兼容版本通过一个唯一的主版本标识符来区分。除了主版本标识符外，还包含一个次要版本标识符，用来区分库的主要版本中兼容的次要版本。真实名称的格式规范： libname.so.major-id.minor-id 。

```
  libdemo.so.1.0.1
  libdemo.so.1.0.2
  libdemo.so.2.0.0
  libdemo.so.5.0
```

共享库的 soname 包括相应的真实名称中的主版本标识符，但不包含次要版本标识符。因此 soname 的形式为 libname.so.major-id 。通常会将 soname 创建为包含真实名称的目录中的一个相对符号链接。下面是一些 soname 的例子以及它们可能通过符号链接指向的真实名称：

```
  libdemo.so.1     -libdemo.so.1.0.2 
  libdemo.so.2     -libdemo.so.2.0.0
  libreadline.so.5 -libreadline.so.5.0
```



### 使用标准规范创建一个共享库

```

  $ gcc -g -c fPIC -Wall mod1.c mod2.c mod3.c
  $ gcc -g -shared -W1,-soname,libdemo.so.1 -o libdemo.so.1.0.1 mod1.o mpd2.o mpd3.o

  $ ln -s libdemo.so.1.0.1 libdemo.so.1  // 创建符号链接 =》 soname
  $ ln -s libdemo.so.1 libdemo.so        // 创建符号链接 =》 连接器名称 

  $ ls -l libdemo.so* | awk '{print $1, $9, $10, $11}'  // 验证配置
  lrwxrwxrwx libdemo.so -libdemo.so.1
  lrwxrwxrwx libdemo.so.1 -libdemo.so.1.0.1
  -rwxr-xr-x libdemo.so.1.0.1
  
  $ gcc -g -Wall -o prog prog.c -L. -ldemo
  $ LD_LIBRARY_PATH=. ./prog
```



### 安装共享库

一般来讲，共享库及其关联的符号链接会被安装在其中一个标准库目录中，标准库目录包括：

* */lib* - 应该将系统启动时用到的库安装在这个目录中
* */usr/lib* - 大多数标准库安装的目录
* */usr/local/lib* - 应该将非标准或者实验性的库安装在这个目录中 
* 在 */etc/ld.so.conf* 中列出的目录 

大多数情况下，将文件复制到这些目录中需要具备超级用户的权限。

### ldconfig 解决了共享库的两个潜在问题：

* 共享库可以位于各种目录中，如果动态链接器需要通过搜索所有这些目录来找出一个库并加载这个库，那么整个过程将非常慢。
* 当安装了新版本的库或者删除了旧版本的库，那么 soname 符号链接就不是最新的。

`ldconfig` 程序通过执行两个任务来解决这些问题：

1.它搜索一组标准的目录并创建或者更新一个缓存文件 */etc/ld.so.cache*，包含所有这些目录中的主要库版本列表。动态链接器在运行时解析库名称时会轮流使用这个缓存文件。为了构件这个缓存，`ldconfig` 会搜索在 */etc/ld.so.conf* 中指定的目录，然后搜索 */lib* */usr/lib* 。*/etc/ld.so.conf* 包含目录路径名列表，其中路径名之间用换行、空格、制表符、逗号或者冒号分隔。在一些发行版中，*/usr/local/lib* 也位于这个列表中（如果不在这个列表中，就需要手工将其添加到列表中）。

2.他检查每个库的各个主要版本的最新次要版本号，以找出嵌入的 soname，然后在同一目录中为每个 soname 创建（或更新）相对链接符号。

在默认情况下，`ldconfig` 会执行上面两个动作，但可以使用命令行选项来指定它执行其中一个动作：`-N` 会禁止缓存的重建，`-X` 会禁止 soname 符号链接的创建。此外，`-v` 会输出描述执行动作的信息。



### ldconfig

每当安装了一个新的库，更新或者删除了一个已有的库，以及 */etc/l.so.conf* 中的目录列表被修改，都应该运行 `ldconfig` 。


```
  $ mv libdemo.so.1.0.1 libdemo.so.2.0.0 /usr/lib    
  $ ldconfig -v | grep libdemo                        
  libdemo.so.1 -libdemo.so.1.0.1 (changed)
  libdemo.so.2 -libdemo.so.2.0.0 (changed)

  $ cd /usr/lib
  $ ls -l libdemo* | awk '{print $1, $9, $10, $11}'  // 列出 /usr/lib 中名为 libdemo 的文件
  lrwxrwxrwx libdemo.so.1 -libdemo.so.1.0.1
  -rwxr-xr-x libdemo.so.1.0.1
  lrwxrwxrwx libdemo.so.2 -libdemo.so.2.0.0
  -rwxr-xr-x libdemo.so.2.0.0

  $ ln -s libdemo.so.2 libdemo.so                    // 为链接器名程创建符号链接
  
  $ mv libdemo.so.2.0.1 /usr/lib                     // 安装库的 2.x 次要版本，链接器名称指向
                                                     // 最新的soname

  $ ldconfig -v | grep libdemo                        
  libdemo.so.1 -libdemo.so.1.0.1
  libdemo.so.2 -libdemo.so.2.0.1 (changed)
```



### 升级共享库


```
  // 创建共享库的 1.0.2 版本
  $ gcc -g -c -fPID -Wall mod1.c mod2.c mod3.c
  $ gcc -g -shared -WL,-some,libdemo.so.1 -o libdemo.so.1.0.2 mod1.o mod2.o mod3.o

  $ mv libdemo.so.1.0.2 /usr/lib
  $ ldconfig -v | grep libdemo
  libdemo.so.1 -libdemo.so.1.0.2 (changed)

  // 创建共享库的 2.0.0 版本
  $ gcc -g -c -fPID -Wall mod1.c mod2.c mod3.c
  $ gcc -g -shared -WL,-some,libdemo.so.2 -o libdemo.so.2.0.0 mod1.o mod2.o mod3.o

  $ mv libdemo.so.2.0.0 /usr/lib  // ldconfig 会自动为 2.0.0 创建一个 soname 符号链接 libdemo.so.2
  $ ldconfig -v | grep libdemo               
  libdemo.so.1 -libdemo.so.1.0.2
  libdemo.so.2 -libdemo.so.2.0.0 (changed)

  $ cd /usr/lib
  $ ln -sf libdemo.so.2 libdemo.so   // 更新链接器名称
```



### 第三种指定库搜索目录的方式：

```
  $ gcc -g -Wall -Wl,-rpath,/home/mtk/pdir -o prog prog.c libdemo.so
```



