# [什么是进程内存](https://www.gnu.org/software/libc/manual/html_node/Memory-Concepts.html#Memory-Concepts)

进程可以获取的最基本的资源之一就是内存。有多种不同的方式组织系统内存，比较典型的是：每个进程拥有一个线性的虚拟地址空间，这些地址从零到一个最大值。它们不必是连续的，也就是说，并不是所有这些地址都用来存储数据。

## 页

虚拟内存划分为页（典型的页大小有 `4096B`--32位系统，`8192B`--64位系统）。虚拟内存的每一个（有效）页都对应一个物理内存页（称为帧）或者一些二级存储（通常是磁盘空间）。磁盘空间可能是交换空间或者只是一些普通的磁盘文件。实际上，有时候一个完全是 `0` 的页根本不表示任何有效的内容---只是标志它是全零。

物理内存或二级存储的一个页，可以表示属于多个进程的多个虚拟页。这是很普遍的，例如，被 GNU C 库代码占用的虚拟内存。The same real memory frame containing the `printf()` function backs a virtual memory page in each of the existing processes that has a `printf()` call in its program. 

为了使程序可以访问虚拟页的任何部分，这个虚拟页必须在那一刻被“连接到”一个物理页。但是由于虚拟内存比实际内存多的多，而每个程序仅有部分页需要驻留在物理内存，所以程序未使用的页拷贝被保存到二级存储，页必须定期在物理内存和二级存储之间来回移动。当一个进程需要访问它们时，内核把它们放入到物理内存，不再需要时再撤回到二级存储。这项运动被称为页调度。（为了优化性能，使操作的代价最低，内核往往是把物理内存中近期不可能使用的页替换出来）。

当一个程序试图访问一个页，而此刻尚没有物理内存支持时，这被称为页面故障。当页面故障发生时，内核推迟处理，（然后在物理内存和二级存储间移动），把页“连接”到一个物理页（这就是所谓的 “paging in” 或 “faulting in”），然后恢复进程。因此，从进程的角度来看，页总是在物理内存中。事实上，对进程来讲，所有的页总是看起来在物理内存中。除了一件事：指令执行的时间通常是几纳秒，此时突然增多了（因为内核通常必须做 I/O 来完成页面移动）。

## 内存分配

在每一个虚拟地址空间中，进程必须跟踪某段地址上存储的是什么，这个过程称为内存分配。分配通常会让人联想到资源紧张，好在虚拟内存比实际内存要多的多，所以这通常不是什么问题。进程中的内存分配，大体只存在一个问题：确保相同的内存字节不用于存储两个不同的东西。

进程分配内存主要有两种方式：通过 `exec()` 和编程。实际上，`fork()` 是第三种方式，但它不是很有趣。

`exec()` 为一个进程创建虚拟地址空间，加载基础程序，然后执行程序。它是由 “exec” 家族函数完成的（例如 `execl()`）。这个操作需要一个程序文件（一个可执行文件），然后分配空间载入可执行文件中的所有数据，并将控制权转交给进程。这些数据主要是程序的指令（文本），程序的字面值和常量，甚至还有一些变量：静态存储的 C 变量。

一旦程序开始执行，它利用可编程的分配方式来获得额外的内存。在基于 GNU C 库的 C 程序，有两种可编程的分配方式：自动地和动态地。

内存映射 IO 是动态分配虚拟内存的另一种形式。它把内存映射到一个普通文件，进程空间的特定范围的内容和文件的内容完全相同。内核会初始化虚拟内存，将其置为文件的内容，如果你修改了内存，内核将把修改写入该文件。请注意，借助虚拟内存和页面故障这些强大的魔法，内核没有理由读这个文件，或者为文件的内容分配物理内存，除非程序确实要访问虚拟内存时才会这么做。

## 内存释放

正如可编程分配内存，程序可以通过编程方式释放（`free()`）内存。你不能释放由 `exec()` 分配的内存！！！当程序 `exit()` 或者 `exec()` 时，你可能会说，哦，它所有的内存都被释放了。但是由于在这两种情况下地址空间已不复存在，这种想法没多大意义。

## 段

进程的虚拟地址空间被划分成段。段是一个连续的虚拟地址范围。有三个重要的段，分别是：

* **文本段** 包含程序的指令、字面值和静态常量。它是通过 `exec()` 分配的，和虚拟地址空间拥有相同的存在时间。

* **数据段** 是程序用来存储工作数据的。包括初始化的全局变量和静态变量、未初始化的全局变量和静态变量。它可以被 `exec()` 预先分配和预先载入，进程可以调用函数扩展或缩小它。其下端是固定的。

* **堆栈段** 包含一个程序堆和栈。它随着堆栈的增长而增长，但在堆栈收缩时不会收缩。

```？
                          +---------------+
                          | Kernel        | 映射到进程虚拟内存，但程序无法访问
               0xC0000000 +---------------+
                          | argv, environ |
                          +---------------+
                          | Stack       ↓ | 
             Top of Stack +...............+
                          |               |
                          |               | 
            Program Break +...............+
                          |               |
                          | Heap        ↑ |
                          |               |
                          +---------------+
                          | Uninitialized |
                          +---------------+
                          | Initialized   | 
                          +---------------+
                          | Text          | 
               0x08048000 +---------------+
               0x00000000 +---------------+
```