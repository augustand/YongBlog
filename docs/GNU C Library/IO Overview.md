# [IO 基础](https://www.gnu.org/software/libc/manual/html_node/I_002fO-Overview.html#I_002fO-Overview)

大多数程序需要输入(读数据)或者输出(写数据)，或者两个都需要，它们扮演着非常重要的角色。GNU C 库为此提供了一个非常庞大的输入输出函数集，而其中最难的地方往往是：如何决定哪些函数是最合适你的! 　　 

本章介绍输入和输出的概念，以及相关术语。

## 什么是输入，什么是输出

当你开始读或写一个文件的内容之前，你必须建立一个到文件的“连接”或者说是“通信通道”。这个过程称为“打开文件”。你打开一个文件，然后读、写，或两者兼而有之。

连接一个打开的文件，既可以通过一个流也可以通过一个文件描述符。你把它作为一个参数传递给函数，以告诉函数对哪一个文件执行读或写操作。某些函数是基于流的，而另一些则是基于文件描述符。

当你已经完成文件的读或写，你可以关闭该文件以终止连接。一旦你已经关闭一个流或文件描述符，你不能再对其执行任何输入或输出操作。

### 文件描述符和流

当你想对一个文件执行输入或输出时，你必须连接你的程序和这个文件。你有两个选择：文件描述符和流。文件描述符用 `int` 类型表示，而流用 `FILE *` 表示。

文件描述符提供一种原始的、底层的接口，执行输入和输出操作。文件描述符和流，可以表示到一个设备（如终端）的连接，或者是到一个管道或套接字的连接（用来和其它进程通信），以及到一个普通文件的连接。但是，如果你想对特定的设备执行控制操作，你必须使用文件描述符：没有设备可以通过流来操作。另外，如果你的程序需要特殊模式的输入或输出，如非阻塞(或轮询)，你也必须使用文件描述符。

流提供了一个高层的接口，它是基于文件描述符设施的一层包装器。流接口对几乎所有类型的文件都作同等处理，唯一的区别是它自带的缓冲有三种风格，你可以自己选择。

使用流接口的主要优势是：比起文件描述符接口，执行实际输入和输出操作(不是控制操作)的函数集更加的丰富。文件描述符接口，只提供了简单的传输字符序列的函数；但是流接口还提供了强大的可格式化的输入和输出函数(`printf()` 和 `scanf()`)，以及面向行的输入和输出函数。 　　 

既然流是基于文件描述符实现的，你可以从一个流提取文件描述符，然后直接通过文件描述符执行底层操作。你也可以以文件描述符的方式打开一个文件，然后把文件描述符转化成一个流。

一般来说，你应该坚持使用流而不是文件描述符，除非你需要的操作只能通过文件描述符执行。如果你是一个刚入道的程序员，并且不确定使用哪些函数，我们建议你专注于格式化的输入函数和格式化的输出函数。

如果你担心程序的可移植性，你也应该清楚：文件描述符并不比流有更好的可移植性。你可以期望任何运行 ISO C 的系统支持流，但非 GNU 系统可能不能完全支持文件描述符，而只是支持一个子集。不过，GNU C 库大多数基于文件描述符的函数，是符合 POSIX.1 标准的。

> 译注：我觉得仁者见仁，智者见智。文件描述符接口，对于完成输入输出更加的直接，可操控性比较强。流接口，在某些方面多少有些臃肿，而且其性能也值得怀疑。如果你只使用基础的文件描述符函数，那么在支持 POSIX 的系统上，可移植性是良好的。另外，你可以适当封装文件描述符的基础函数，编写自己的流函数集，以执行更特定的操作。

### 文件位置

一个打开的文件，包含很多属性，其中之一是文件位置---用来跟踪文件中下一次被读或写的字符。在 GNU 系统，以及所有的 POSIX.1 系统，文件位置是一个整数，表示从文件开始到当前位置的字节数。

通常，文件被打开时，文件位置被置为开始处（`0`）。每当读取或写入一个字符，文件位置就会增加 `1`。换句话说，访问文件时通常是连续的。

普通文件允许在文件内的任何位置执行读或写。一些其它类型的文件也允许如此。支持这种行为的文件，有时也被称为“随机存取文件”。你可以通过一个流函数 `fseek()` 改变文件位置，也可以通过文件描述符函数 `lseek()` 改变文件位置。当访问一个不支持“随机存取”的文件时，如果你尝试改变它的文件位置，会发生 `ESPIPE` 错误。

通过流或文件描述符打开文件，并执行追加写操作时比较特殊：对该文件的输出总是顺序追加到文件末尾，而不管文件位置。然而，文件位置在控制读操作时仍然非常有用。

如果你仔细考虑一下，你应该会意识到，多个程序可以在同一时间读取同一个文件。为了保证每个程序有自己的读秩序，每个程序必须有它自己的文件指针---它不受其它程序的影响。

事实上，每个文件在被打开时，会创建一个独立的文件位置。甚至在同一个程序打开同一个文件两次，所得到的流或者文件描述符，其文件位置都是独立的。

但是，如果你打开一个描述符，然后把它复制到另一个描述符，这两个描述符共享同一个文件位置：一个描述符对文件位置的改变，会影响到另一个。

###

## 文件名

为了连接到一个文件，或执行其它操作（如删除一个文件），你需要一些关联文件的方法。几乎所有的文件都有文件名，甚至是设备文件，比如磁带驱动器或终端。你指定文件名，以说明你打算打开或操作的文件。

本节描述了文件名的约定和操作系统是如何与它们工作的。

### 目录

为了理解文件名的语法，你需要了解文件系统是如何组织成层的。

目录是一个文件，它包含一个名字列表，可以通过名字关联到其它文件。这些名字被称为链接或目录项。有时，人们会说“一个目录中的文件”；但是，事实上，目录只包含指向文件的指针，而不包含文件本身。

目录中包含的名字，称为“文件名组件”。一般来说，一个文件名由一个或多个这样的组件组成，用斜杠字符（'/'）分隔。A file name which is just one component names a file with respect to its directory. A file name with multiple components names a directory， and then a file in that directory， and so on. 

一些其它的文档，比如 POSIX 标准，使用术语 `pathname` 来表示我们所称呼的文件名，使用术语 `filename component` 或 `pathname component` 表示我们所称呼的文件名组件。我们的文档里不这么用，因为我们觉得 path 太让人困惑了，它能表示很多种不同的意思。我们的文档里，总是使用 `filename` 和 `filename component` （有时直接用 `component`）。对于一些遵循 POSIX 标准的宏，我们使用 POSIX 定义的名字，比如 `PATH_MAX`。这些宏是由 POSIX 标准制定的，我们不能改变它们。  

### 文件名解析

文件名由文件名组件组成，之间用 '/' 分隔。在 GNU C 库支持的系统上，连续多个 '/' 等价于一个 '/'。　

通过文件名确定文件的过程，称为“文件名解析”。文件系统中的每个文件和目录，都在内核的 inode 表存储着唯一的一条记录，包含了文件的各种信息。当内核解析一个文件名时，它会遍历每个目录项，查找下一个入口项的 inode。比如 */home/king/test.js*，起始项是 /，先获取 home 的 inode，然后获取 king 的 inode，最后获取 test.js 的 inode。内核也采用缓存储存目录的解析结果，基于＂时间局部性＂原理，可以为后续访问更快的提供查询结果。

如果文件名是以 */* 开始的，这个文件名就称为“绝对文件名”（“绝对路径名”），例如 */usr/bin/nginx*。否则，称为“相对文件名”（“相对路径名”），最先开始的组件被置为当前工作目录，例如 *bin/nginx*。

文件名组件 *.* 和 *..* 有特殊的意义。每个目录都有这两项。*.* 关联到当前目录自己，*..* 关联到当前目录的父目录。此外，根目录 */* 中的 *..* 关联到它自己，*/..* 等价于 */.*。如果你想定位到根目录，使用文件名 */*。如果你想定位到当前工作目录，使用文件名 *.* 或者 *./.*。

这里给出了一些文件名的例子：

```?
/a          文件基本名是 a，在根目录中
/a/b        文件基本名是 b，在根目录中的 a 目录中
a           文件基本名是 a，在当前工作目录中
/a/./b      等价于 /a/b
./a         文件基本名是 a，在当前工作目录中
../a        文件基本名是 a，在当前工作目录的父目录中
```

<span>

> 译注：
>
name | 例子 | 描述
-----|-----|-----
filename|/a/b.txt|文件名
basename|b|文件基本名
txtname|.txt|文件扩展名

### 文件名错误

那些以文件名作为参数的函数，通常会检查文件名的语法是否正确，以及是否对查找文件造成困扰。如果是这样，会报告错误，设置 `errno` 值。相关的 `errno` 值如下所示：

* `EACCES` 当前进程对指定的文件没有查找权限。

* `ENAMETOOLONG` 指定的文件名长度大于 `PATH_MAX`，或者单个文件名组件长度大于 `NAME_MAX`。

  在 GNU/Hurd 系统，没有文件名长度的限制。此外，一些文件系统可能也会移除文件名组件的长度限制。

* `ENOENT` 文件名中的目录组件不存在，或者目录组件是一个符号链接并且它指向的文件不存在。

* `ENOTDIR` 文件名中的目录组件存在，但是并非目录。

* `ELOOP` 解析文件名时，涉及到太多的符号链接。内核对此有一个上限，你不应该超过这个限制。

### 文件名的可移植性

我们上面讨论的文件名语法，通常都是 GNU 系统和其它 POSIX 系统使用的规则。不过，其它的系统也可能使用这些规则。

关于文件名的可移植性，有两点非常重要：

* 如果你的程序依赖文件名语法，或者含有文件名的字符串字面值，那么让程序可以在多系统中运行是非常困难的。
* 甚至在同一个系统，也有可能会出现移植性问题。比如，你可能通过网络访问另一个系统。

ISO C 标准没有规定文件名语法，只规定文件名应该是字符串。在不同的系统中，文件名的长度限制是不同的，文件名中可以出现的合法字符是不同的，文件名的语法和相关的文件结构也可能是不同的。

POSIX.1 标准允许实现添加额外的文件名语法限制，包括：文件名可以出现的合法字符、文件名的长度和文件名组件的长度。不管怎么样，在 GNU 系统，除了 null 字符，其它字符都可以出现在文件名中；在 GNU/Hurd 系统，没有文件名长度的限制。


